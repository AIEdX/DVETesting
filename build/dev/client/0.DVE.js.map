{"version":3,"file":"0.DVE.js","mappings":";;;;;;;;;;;;;;;;AAAmD;AACG;AACA;AACtD;AACA;AACA;AACA;AACO;AACP,gBAAgB,sEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,oEAAiB;AACzB;AACA,YAAY,6EAA0B;AACtC;AACA,KAAK;AACL,wCAAwC;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACjKO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACjBA;AAC0C;AAC1C;AACmD;AAC5C,oBAAoB,8DAAU,CAAC,mEAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;ACxBiE;AAC1B;AACjC;AACP,wBAAwB,2EAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,iDAAK;AACxB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACtCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClC8C;AACuD;AAC7C;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAyB;AAClD,YAAY,8EAA0B;AACtC,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAA8B;AAC1C,YAAY,8EAAkC;AAC9C;AACA;AACA,YAAY,gEAAoB;AAChC,YAAY,2EAA+B;AAC3C;AACA;AACA,YAAY,qEAAyB;AACrC,YAAY,gFAAoC;AAChD;AACA;AACA,YAAY,mEAAuB;AACnC,YAAY,8EAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,UAAU,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAAyB;AAC7D,YAAY,kFAA8B;AAC1C;AACA;AACA;AACA;AACA,yBAAyB,6EAAyB;AAClD,YAAY,kFAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAyB,OAAO,iEAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,6BAA6B,UAAU,GAAG,GAAG,GAAG,WAAW;AAC3D,yBAAyB,+EAA2B;AACpD;AACA,YAAY,iEAAqB;AACjC;AACA;AACA,QAAQ,gFAA4B;AACpC;AACA,SAAS;AACT;AACA;AACA,QAAQ,gFAA4B;AACpC,yBAAyB,6EAAyB,OAAO,iEAAqB;AAC9E;AACA;AACA,yBAAyB,6EAAyB;AAClD,YAAY,gFAA4B;AACxC,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAyB;AAClD,YAAY,kFAA8B;AAC1C,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA,yBAAyB,6EAAyB,GAAG,+EAA2B;AAChF;AACA;AACA,yBAAyB,6EAAyB,GAAG,iFAA6B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrMO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACnBM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpBA;AACgF;AAChF;AAC2C;AACa;AACV;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,IAAI,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+BAA+B,iBAAiB,GAAG,iBAAiB;AACpE,4BAA4B,mDAAQ;AACpC,QAAQ,8DAAkB;AAC1B;AACA;AACA;AACA,4BAA4B,6EAAyB;AACrD,YAAY,iFAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH;AACpH;AACA,4CAA4C,IAAI;AAChD;AACA,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzKU;;;;;;;;;;;;;;;;ACAgC;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,GAAG,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3HO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACpCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACTA;AACoG;AACpG;AACwC;AACe;AACb;AACW;AACP;AACS;AAChD;AACP;AACA;AACA;AACA,cAAc;AACd,sBAAsB;AACtB,cAAc;AACd;AACA,mBAAmB;AACnB,gBAAgB,mDAAQ;AACxB,kBAAkB;AAClB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,qCAAqC;AACrC,yCAAyC,mDAAQ;AACjD;AACA;AACA,KAAK;AACL;AACA,mCAAmC,gEAAW;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,wCAAwC,QAAQ;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,6EAAyB;AACtD,gBAAgB,oFAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,2BAA2B,6EAAyB;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6EAAyB;AACxD,gBAAgB,uFAAmC;AACnD;AACA;AACA;AACA;AACA;AACA,+BAA+B,6EAAyB;AACxD,gBAAgB,uFAAmC;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,+EAA2B;AACrD,KAAK;AACL;AACA,0BAA0B,iDAAI;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAA2B;AACjD;AACA;AACA,sBAAsB,iFAA6B;AACnD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,6EAAyB;AACnD,KAAK;AACL;AACA,yBAAyB,uDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6EAAyB;AAC/C,SAAS,kFAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8EAA0B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iFAA6B;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS,gFAA4B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAW;AACrC;AACA,SAAS,kFAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oFAAgC;AACzC;AACA;AACA;AACA,IAAI,qFAAiC;AACrC;AACA,SAAS,uFAAmC;AAC5C;AACA;AACA,IAAI,qFAAiC;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;ACpQgC;AACD;AACI;AACM;AACR;AACS;;;;;;;;;;;;;;;ACL1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,GAAG,OAAO,GAAG,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtKU;;;;;;;;;;;;;;;;ACA2C;AACrD;AACA;AACA;AACO;AACP,wBAAwB,8DAAU;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,sCAAsC,8DAAU;AAChD;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,2BAA2B,kBAAkB;AAC7C,4BAA4B,kBAAkB;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,8DAAU;AAC1C;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA,uBAAuB,uEAAmB,CAAC,0EAAsB;AACjE,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT,qCAAqC,8DAAU;AAC/C;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT,+BAA+B,kBAAkB;AACjD;AACA;AACA,uBAAuB,0EAAsB;AAC7C,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,+BAA+B,8DAAU;AACzC;AACA,gBAAgB,0EAAsB;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,0BAA0B,8DAAU;AACpC;AACA,gBAAgB,0EAAsB;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC1IiC;AACY","sources":["webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Settings/EngineSettings.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldBounds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldSpaces.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util.helper.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/CreatePromiseCheck.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/Queue.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Comm/Comm.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Constants/Messages.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Data/DataSync.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Manager/CommManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Meta/Comm/Comm.types.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Queue/QueueManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Queue/SyncedQueue.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Tasks/PromiseTasks.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Tasks/Tasks.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/ThreadComm.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/index.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/tools/Queue.js","webpack://dve-testing/../../DSLIBS/voxelspaces/dist/Classes/VoxelSpace.js","webpack://dve-testing/../../DSLIBS/voxelspaces/dist/Types/VoxelSpaces.types.js","webpack://dve-testing/../../DSLIBS/voxelspaces/dist/VoxelSpaces.js","webpack://dve-testing/../../DSLIBS/voxelspaces/dist/index.js"],"sourcesContent":["import { Util } from \"../../Global/Util.helper.js\";\r\nimport { WorldBounds } from \"../World/WorldBounds.js\";\r\nimport { WorldSpaces } from \"../World/WorldSpaces.js\";\r\n/**# Engine Settings\r\n * ---\r\n * Handles common settings for all contexts\r\n */\r\nexport const EngineSettings = {\r\n    enviorment: Util.getEnviorment(),\r\n    //context: <EngineSettingsContext>\"MatrixLoadedThread\",\r\n    settings: {\r\n        nexus: {\r\n            enabled: false,\r\n            autoSyncChunks: true,\r\n            autoSyncVoxelPalette: true,\r\n        },\r\n        data: {\r\n            enabled: false,\r\n            autoSyncChunks: true,\r\n            mode: \"server\",\r\n        },\r\n        fx: {\r\n            enabled: false,\r\n            autoSyncChunks: true,\r\n            autoSyncVoxelPalette: true,\r\n        },\r\n        server: {\r\n            enabled: false,\r\n        },\r\n        richWorld: {\r\n            enabled: false,\r\n            autoSyncChunks: true,\r\n            autoSyncVoxelPalette: true,\r\n        },\r\n        textures: {\r\n            animationTime: 20,\r\n            textureSize: 16,\r\n            mipMapSizes: [16, 12, 8, 4],\r\n        },\r\n        updating: {\r\n            autoRebuild: true,\r\n        },\r\n        world: {\r\n            maxX: Infinity,\r\n            minX: -Infinity,\r\n            maxZ: Infinity,\r\n            minZ: -Infinity,\r\n            maxY: 256,\r\n            minY: 0,\r\n        },\r\n        regions: {\r\n            regionXPow2: 9,\r\n            regionYPow2: 8,\r\n            regionZPow2: 9,\r\n        },\r\n        chunks: {\r\n            autoHeightMap: true,\r\n            chunkXPow2: 4,\r\n            chunkYPow2: 4,\r\n            chunkZPow2: 4,\r\n        },\r\n        voxels: {\r\n            doColors: true,\r\n        },\r\n        flow: {\r\n            enable: true,\r\n        },\r\n        lighting: {\r\n            doAO: true,\r\n            doSunLight: true,\r\n            doRGBLight: true,\r\n            autoRGBLight: true,\r\n            autoSunLight: true,\r\n        },\r\n        meshes: {\r\n            clearChachedGeometry: true,\r\n            checkMagmaCollisions: false,\r\n            checkLiquidCollisions: false,\r\n            checkFloraCollisions: false,\r\n            checkSolidCollisions: false,\r\n            seralize: false,\r\n            pickable: false,\r\n        },\r\n        materials: {\r\n            mode: \"classic\",\r\n            doAO: true,\r\n            doSunLight: true,\r\n            doRGBLight: true,\r\n            disableFloraShaderEffects: false,\r\n            disableLiquidShaderEffects: false,\r\n        },\r\n    },\r\n    getSettings() {\r\n        return this.settings;\r\n    },\r\n    syncSettings(data) {\r\n        //safetly set data without prototype pollution\r\n        for (const settingsKey of Object.keys(data)) {\r\n            if (settingsKey.includes(\"__\")) {\r\n                throw new Error(\"Can not include properties with multpile underscores.\");\r\n            }\r\n            if (this.settings[settingsKey] !== undefined) {\r\n                for (const propertyKey of Object.keys(data[settingsKey])) {\r\n                    if (propertyKey.includes(\"__\")) {\r\n                        throw new Error(\"Can not include properties with multpile underscores.\");\r\n                    }\r\n                    if (this.settings[settingsKey][propertyKey] !== undefined) {\r\n                        //@ts-ignore\r\n                        this.settings[settingsKey][propertyKey] = data[settingsKey][propertyKey];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.__syncWithObjects();\r\n    },\r\n    __syncWithObjects() {\r\n        WorldSpaces.$INIT(this.settings);\r\n        if (this.settings.world) {\r\n            WorldBounds.setWorldBounds(this.settings.world.minX, this.settings.world.maxX, this.settings.world.minZ, this.settings.world.maxZ, this.settings.world.minY, this.settings.world.maxY);\r\n        }\r\n    },\r\n    syncWithWorldBounds(worldBounds) { },\r\n    getSettingsCopy() {\r\n        return JSON.parse(JSON.stringify(this.settings));\r\n    },\r\n    syncChunkInRichWorldThread() {\r\n        return (this.settings.richWorld.enabled && this.settings.richWorld.autoSyncChunks);\r\n    },\r\n    richDataEnabled() {\r\n        return this.settings.richWorld.enabled;\r\n    },\r\n    syncChunkInFXThread() {\r\n        return this.settings.fx.enabled && this.settings.fx.autoSyncChunks;\r\n    },\r\n    syncChunkInDataThread() {\r\n        return this.settings.data.enabled && this.settings.data.autoSyncChunks;\r\n    },\r\n    syncChunksInNexusThread() {\r\n        return this.settings.nexus.enabled && this.settings.nexus.autoSyncChunks;\r\n    },\r\n    doSunPropagation() {\r\n        return this.settings.lighting.autoSunLight == true;\r\n    },\r\n    doRGBPropagation() {\r\n        return this.settings.lighting.autoRGBLight == true;\r\n    },\r\n    doLight() {\r\n        return this.doRGBPropagation() || this.doSunPropagation();\r\n    },\r\n    doFlow() {\r\n        return this.settings.flow.enable;\r\n    },\r\n    saveWorldData() {\r\n        return this.settings.data.enabled;\r\n    },\r\n    isServer() {\r\n        return this.settings.server.enabled && this.enviorment == \"node\";\r\n    },\r\n    isClient() {\r\n        return this.enviorment != \"browser\";\r\n    },\r\n};\r\n","export const WorldBounds = {\r\n    bounds: {\r\n        MinZ: -Infinity,\r\n        MaxZ: Infinity,\r\n        MinX: -Infinity,\r\n        MaxX: Infinity,\r\n        MinY: 0,\r\n        MaxY: 256,\r\n    },\r\n    setWorldBounds(minX, maxX, minZ, maxZ, minY, maxY) {\r\n        this.bounds.MinX = minX;\r\n        this.bounds.MaxX = maxX;\r\n        this.bounds.MinX = minZ;\r\n        this.bounds.MaxZ = maxZ;\r\n        this.bounds.MinY = minY;\r\n        this.bounds.MaxY = maxY;\r\n    },\r\n};\r\n","//types\r\nimport { VoxelSpaces } from \"voxelspaces\";\r\n//Objects\r\nimport { Util } from \"../../Global/Util.helper.js\";\r\nexport const WorldSpaces = Util.merge(VoxelSpaces.getVoxelSpaces(), {\r\n    $INIT(settings) {\r\n        WorldSpaces.setDimensions({\r\n            regions: {\r\n                x: settings.regions.regionXPow2,\r\n                y: settings.regions.regionYPow2,\r\n                z: settings.regions.regionZPow2,\r\n            },\r\n            columns: {\r\n                x: settings.chunks.chunkXPow2,\r\n                y: settings.regions.regionYPow2,\r\n                z: settings.chunks.chunkZPow2,\r\n            },\r\n            chunks: {\r\n                x: settings.chunks.chunkXPow2,\r\n                y: settings.chunks.chunkYPow2,\r\n                z: settings.chunks.chunkZPow2,\r\n            },\r\n        });\r\n    },\r\n});\r\n","import { CreatePromiseCheck } from \"./Util/CreatePromiseCheck.js\";\r\nimport { Queue } from \"./Util/Queue.js\";\r\nexport const Util = {\r\n    createPromiseCheck: CreatePromiseCheck,\r\n    getEnviorment() {\r\n        let environment = \"browser\";\r\n        //@ts-ignore\r\n        if (typeof process !== \"undefined\" && typeof Worker === \"undefined\") {\r\n            environment = \"node\";\r\n        }\r\n        return environment;\r\n    },\r\n    getAQueue() {\r\n        return new Queue();\r\n    },\r\n    merge(target, newObject) {\r\n        return Object.assign(target, newObject);\r\n    },\r\n    degtoRad(degrees) {\r\n        return degrees * (Math.PI / 180);\r\n    },\r\n    radToDeg(radians) {\r\n        return radians * (180 / Math.PI);\r\n    },\r\n    convertBufferToSAB(buffer) {\r\n        const sab = new SharedArrayBuffer(buffer.byteLength);\r\n        const temp = new Uint8Array(buffer);\r\n        const temp2 = new Uint8Array(sab);\r\n        temp2.set(temp, 0);\r\n        return sab;\r\n    },\r\n    converSABToBuffer(buffer) {\r\n        const newBuffer = new ArrayBuffer(buffer.byteLength);\r\n        const temp = new Uint8Array(buffer);\r\n        const temp2 = new Uint8Array(newBuffer);\r\n        temp2.set(temp, 0);\r\n        return newBuffer;\r\n    },\r\n};\r\n","export const CreatePromiseCheck = (data) => {\r\n    return new Promise((resolve) => {\r\n        const times = {\r\n            inte: -1,\r\n            fail: -1,\r\n        };\r\n        times.inte = setInterval(() => {\r\n            if (data.check()) {\r\n                if (data.onReady) {\r\n                    data.onReady();\r\n                }\r\n                if (times.fail > -1) {\r\n                    clearTimeout(times.fail);\r\n                }\r\n                clearInterval(times.inte);\r\n                resolve(true);\r\n            }\r\n        }, data.checkInterval);\r\n        if (data.failTimeOut) {\r\n            times.fail = setTimeout(() => {\r\n                clearInterval(times.inte);\r\n                if (data.onFail) {\r\n                    data.onFail();\r\n                }\r\n                resolve(false);\r\n            }, data.failTimeOut);\r\n        }\r\n    });\r\n};\r\n","class QueueNode {\r\n    data;\r\n    next;\r\n    constructor(data) {\r\n        this.data = data;\r\n    }\r\n}\r\nexport class Queue {\r\n    size = 0;\r\n    first;\r\n    last;\r\n    enqueue(data) {\r\n        const node = new QueueNode(data);\r\n        if (this.size == 0) {\r\n            this.first = node;\r\n            this.last = node;\r\n        }\r\n        else {\r\n            this.last.next = node;\r\n            this.last = node;\r\n        }\r\n        this.size++;\r\n    }\r\n    dequeue() {\r\n        if (this.size == 0)\r\n            return null;\r\n        if (!this.first)\r\n            return null;\r\n        let prevFirst = this.first;\r\n        this.first = prevFirst.next;\r\n        prevFirst.next = null;\r\n        this.size--;\r\n        return prevFirst.data;\r\n    }\r\n}\r\n","import { ThreadComm } from \"../ThreadComm.js\";\r\nimport { TCMessageHeaders, TCInternalMessages, TCDataSyncMessages, } from \"../Constants/Messages.js\";\r\nimport { PromiseTasks } from \"../Tasks/PromiseTasks.js\";\r\nexport class CommBase {\r\n    name;\r\n    managerName;\r\n    environment = \"browser\";\r\n    __ready = false;\r\n    port = null;\r\n    messageFunctions = {};\r\n    _manager = null;\r\n    constructor(name, managerName = \"worker\", commManager = null) {\r\n        this.name = name;\r\n        this.managerName = managerName;\r\n        this._manager = commManager;\r\n    }\r\n    destroy() {\r\n        if (!this.port)\r\n            return;\r\n        if (\"terminate\" in this.port) {\r\n            this.port.terminate();\r\n        }\r\n    }\r\n    isReady() {\r\n        return this.__ready;\r\n    }\r\n    __sendReadySignal() {\r\n        this.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.IsReady,\r\n            ThreadComm.threadName,\r\n        ]);\r\n    }\r\n    __onSetPortRun = (port) => { };\r\n    isPortSet() {\r\n        return Boolean(this.port);\r\n    }\r\n    onSetPort(set) {\r\n        this.__onSetPortRun = set;\r\n    }\r\n    __handleMessage(data, event) {\r\n        this.onMessage(data, event);\r\n        if (ThreadComm.__isInternalMessage(data)) {\r\n            ThreadComm.__handleInternalMessage(data, event);\r\n            return;\r\n        }\r\n        if (ThreadComm.__isTasks(data)) {\r\n            ThreadComm.__handleTasksMessage(data);\r\n            return;\r\n        }\r\n        if (ThreadComm.__isTasksCheck(data)) {\r\n            ThreadComm.__handleTasksCheckMessage(data);\r\n            return;\r\n        }\r\n        if (ThreadComm.__isDataSync(data)) {\r\n            ThreadComm.__hanldeDataSyncMessage(data);\r\n            return;\r\n        }\r\n        if (this._manager) {\r\n            if (this._manager.__isManagerMessage(data)) {\r\n                this._manager.__handleManagerMessage(data, event);\r\n                return;\r\n            }\r\n        }\r\n        const message = data[0];\r\n        if (this.messageFunctions[message]) {\r\n            this.messageFunctions[message].forEach((_) => _(data, event));\r\n            return;\r\n        }\r\n    }\r\n    setPort(port) {\r\n        if (!port) {\r\n            return this.__throwError(\"Port or worker must not be null.\");\r\n        }\r\n        this.port = port;\r\n        this.__onSetPortRun(port);\r\n        if (this.environment == \"browser\") {\r\n            port.onmessage = (event) => {\r\n                this.__handleMessage(event.data, event);\r\n            };\r\n            port.onmessageerror = (event) => {\r\n                console.log(event);\r\n                this.__throwError(\"Error occured.\");\r\n            };\r\n        }\r\n        if (this.environment == \"node\") {\r\n            port.on(\"message\", (data) => {\r\n                this.__handleMessage(data, data);\r\n            });\r\n            port.on(\"error\", (data) => {\r\n                console.log(data);\r\n                this.__throwError(\"Error occured.\");\r\n            });\r\n        }\r\n        this.__sendReadySignal();\r\n    }\r\n    __throwError(message) {\r\n        throw new Error(`[ThreadComm: ${this.name}] ${message}`);\r\n    }\r\n    sendMessage(message, data = [], transfers) {\r\n        if (!this.port) {\r\n            return this.__throwError(\"Port is not set.\");\r\n        }\r\n        if (this.environment == \"browser\" && transfers) {\r\n            this.port.postMessage([message, ...data], transfers);\r\n            return;\r\n        }\r\n        this.port.postMessage([message, ...data]);\r\n    }\r\n    listenForMessage(message, run) {\r\n        this.messageFunctions[message] ??= [];\r\n        this.messageFunctions[message].push(run);\r\n    }\r\n    connectToComm(commToConnectTo) {\r\n        const channel = new MessageChannel();\r\n        commToConnectTo.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.connectPort,\r\n            this.name,\r\n            this.managerName,\r\n            channel.port1,\r\n        ], [channel.port1]);\r\n        this.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.connectPort,\r\n            commToConnectTo.name,\r\n            commToConnectTo.managerName,\r\n            channel.port2,\r\n        ], [channel.port2]);\r\n    }\r\n    runTasks(id, data, transfers = [], queueId) {\r\n        let mode = 0;\r\n        let tid = \"\";\r\n        if (queueId) {\r\n            mode = 2;\r\n            tid = queueId;\r\n        }\r\n        this.sendMessage(TCMessageHeaders.runTasks, [id, ThreadComm.threadName, mode, tid, data], transfers);\r\n    }\r\n    waitTillTasksExist(id) {\r\n        return new Promise((resolve) => {\r\n            const inte = setInterval(() => {\r\n                this.tasksExist(id, (exists) => {\r\n                    if (exists) {\r\n                        resolve(true);\r\n                        clearInterval(inte);\r\n                    }\r\n                });\r\n            }, 10);\r\n        });\r\n    }\r\n    tasksExist(id, onDone) {\r\n        const promiseId = `${this.name}-${id}-${Date.now()}`;\r\n        this.sendMessage(TCMessageHeaders.checkTasks, [\r\n            id,\r\n            ThreadComm.threadName,\r\n            promiseId,\r\n        ]);\r\n        PromiseTasks.addPromiseTakss(\"tasks-check\", promiseId, (data) => {\r\n            onDone(data);\r\n        });\r\n    }\r\n    runPromiseTasks(id, requestsID, onDone, data, transfers = []) {\r\n        PromiseTasks.addPromiseTakss(id, requestsID, onDone);\r\n        this.sendMessage(TCMessageHeaders.runTasks, [id, ThreadComm.threadName, 1, requestsID, data], transfers);\r\n    }\r\n    __syncQueue(id, sab) {\r\n        this.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.syncQueue,\r\n            ThreadComm.threadName,\r\n            id,\r\n            sab,\r\n        ]);\r\n    }\r\n    __unSyqncQueue(id) {\r\n        this.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.unSyncQueue,\r\n            ThreadComm.threadName,\r\n            id,\r\n        ]);\r\n    }\r\n    syncData(dataType, data, transfers) {\r\n        this.sendMessage(TCMessageHeaders.dataSync, [TCDataSyncMessages.SyncData, dataType, data], transfers);\r\n    }\r\n    unSyncData(dataType, data, transfers) {\r\n        this.sendMessage(TCMessageHeaders.dataSync, [TCDataSyncMessages.UnSyncData, dataType, data], transfers);\r\n    }\r\n    waitTillReady() {\r\n        const self = this;\r\n        return new Promise((resolve, reject) => {\r\n            const inte = setInterval(() => {\r\n                if (this.isReady()) {\r\n                    clearInterval(inte);\r\n                    resolve(true);\r\n                }\r\n            }, 1);\r\n        });\r\n    }\r\n    //meant to be over-ridden for debugging or custom behavior\r\n    onMessage(data, event) { }\r\n}\r\n","export const TCMessageHeaders = Object.freeze({\r\n    internal: -99,\r\n    runTasks: -98,\r\n    checkTasks: -97,\r\n    dataSync: -96,\r\n    message: -95,\r\n});\r\nexport const TCInternalMessages = Object.freeze({\r\n    IsReady: -99,\r\n    nameThread: -98,\r\n    connectPort: -97,\r\n    syncQueue: -96,\r\n    unSyncQueue: -95,\r\n    completeTasks: -94,\r\n    checkTasksResult: -93,\r\n});\r\nexport const TCDataSyncMessages = Object.freeze({\r\n    SyncData: -990,\r\n    UnSyncData: -980,\r\n});\r\n","export class DataSync {\r\n    __onSyncFunctions = [];\r\n    __onUnSyncFunctions = [];\r\n    constructor() { }\r\n    addOnSync(func) {\r\n        this.__onSyncFunctions.push(func);\r\n    }\r\n    addOnUnSync(func) {\r\n        this.__onUnSyncFunctions.push(func);\r\n    }\r\n    sync(data) {\r\n        for (const func of this.__onSyncFunctions) {\r\n            func(data);\r\n        }\r\n    }\r\n    unSync(data) {\r\n        for (const func of this.__onUnSyncFunctions) {\r\n            func(data);\r\n        }\r\n    }\r\n}\r\n","//constants\r\nimport { TCMessageHeaders, TCInternalMessages } from \"../Constants/Messages.js\";\r\n//classes\r\nimport { CommBase } from \"../Comm/Comm.js\";\r\nimport { QueueManager } from \"../Queue/QueueManager.js\";\r\nimport { ThreadComm } from \"../ThreadComm.js\";\r\nexport class CommManager {\r\n    _totalComms = 0;\r\n    _currentCom = 0;\r\n    name = \"\";\r\n    __comms = [];\r\n    __data = {\r\n        name: \"\",\r\n        onPortSet: (port, commName) => { },\r\n    };\r\n    __queues = {};\r\n    messageFunctions = {};\r\n    constructor(data) {\r\n        this.__data = data;\r\n        this.name = data.name;\r\n    }\r\n    __throwError(message) {\r\n        throw new Error(`[ThreadCommManager : ${this.__data.name}] ${message}`);\r\n    }\r\n    connectToCom(commToConnectTo) {\r\n        for (const comm of this.__comms) {\r\n            comm.connectToComm(commToConnectTo);\r\n        }\r\n    }\r\n    destroyAll() {\r\n        for (const comm of this.__comms) {\r\n            comm.destroy();\r\n        }\r\n    }\r\n    isReady() {\r\n        let ready = true;\r\n        for (const comm of this.__comms) {\r\n            if (!comm.isReady())\r\n                ready = false;\r\n        }\r\n        return ready;\r\n    }\r\n    waitTillAllAreReady() {\r\n        const self = this;\r\n        return new Promise((resolve, reject) => {\r\n            const inte = setInterval(() => {\r\n                if (this.isReady()) {\r\n                    clearInterval(inte);\r\n                    resolve(true);\r\n                }\r\n            }, 1);\r\n        });\r\n    }\r\n    addPort(port) {\r\n        this._totalComms++;\r\n        const newCommName = `${this.__data.name}-${this._totalComms}`;\r\n        const newComm = new CommBase(newCommName, this.__data.name, this);\r\n        ThreadComm.addComm(newComm);\r\n        newComm.setPort(port);\r\n        this.__data.onPortSet(port, newCommName);\r\n        this.__comms.push(newComm);\r\n        newComm.sendMessage(TCMessageHeaders.internal, [\r\n            TCInternalMessages.nameThread,\r\n            newCommName,\r\n            this._totalComms,\r\n        ]);\r\n    }\r\n    addPorts(ports) {\r\n        for (const port of ports) {\r\n            this.addPort(port);\r\n        }\r\n    }\r\n    addComms(comms) {\r\n        this._totalComms += comms.length;\r\n        this.__comms.push(...comms);\r\n    }\r\n    __isManagerMessage(data) {\r\n        return this.messageFunctions[data[0]] !== undefined;\r\n    }\r\n    __handleManagerMessage(data, event) {\r\n        if (!this.messageFunctions[data[0]])\r\n            return;\r\n        this.messageFunctions[data[0]].forEach((_) => _(data, event));\r\n    }\r\n    listenForMessage(message, run) {\r\n        this.messageFunctions[message] ??= [];\r\n        this.messageFunctions[message].push(run);\r\n    }\r\n    sendMessageToAll(message, data = [], transfers) {\r\n        for (const comm of this.__comms) {\r\n            comm.sendMessage(message, data, transfers);\r\n        }\r\n    }\r\n    runTasksForAll(id, data, transfers = [], queueId) {\r\n        for (const comm of this.__comms) {\r\n            comm.runTasks(id, data, transfers, queueId);\r\n        }\r\n    }\r\n    runTask(id, data, transfers = [], threadNumber = -1, queueId) {\r\n        if (threadNumber < 0) {\r\n            const comm = this.__comms[this._currentCom];\r\n            comm.runTasks(id, data, transfers, queueId);\r\n            return this.__handleCount();\r\n        }\r\n        else {\r\n            const comm = this.__comms[threadNumber];\r\n            comm.runTasks(id, data, transfers, queueId);\r\n            return threadNumber;\r\n        }\r\n    }\r\n    runPromiseTasks(id, requestsID, onDone, data, transfers = [], threadNumber = -1) {\r\n        if (threadNumber < 0) {\r\n            const comm = this.__comms[this._currentCom];\r\n            comm.runPromiseTasks(id, requestsID, onDone, data, transfers);\r\n            return this.__handleCount();\r\n        }\r\n        else {\r\n            const comm = this.__comms[threadNumber];\r\n            comm.runPromiseTasks(id, requestsID, onDone, data, transfers);\r\n            return threadNumber;\r\n        }\r\n    }\r\n    __handleCount() {\r\n        let countReturn = this._currentCom;\r\n        this._currentCom++;\r\n        if (this._currentCom >= this._totalComms) {\r\n            this._currentCom = 0;\r\n        }\r\n        return countReturn;\r\n    }\r\n    addQueue(id, associatedTasksId, getQueueKey = null, beforeRun = (data) => data, afterRun = (data, thread) => { }, getThread = (data) => -1, getTransfers = (data) => []) {\r\n        if (this.__queues[id]) {\r\n            this.__throwError(`Queue with ${id} already exists.`);\r\n        }\r\n        const newQueue = new QueueManager(id, (data, queueId) => {\r\n            data = beforeRun(data);\r\n            const thread = this.runTask(associatedTasksId, data, getTransfers(data), getThread(data), queueId);\r\n            afterRun(data, thread);\r\n        }, this, getQueueKey);\r\n        this.__queues[id] = newQueue;\r\n        return newQueue;\r\n    }\r\n    getQueue(id) {\r\n        const queue = this.__queues[id];\r\n        if (!queue) {\r\n            this.__throwError(`Queue with ${id} does not exists.`);\r\n        }\r\n        return queue;\r\n    }\r\n    __syncQueue(id, sab) {\r\n        for (const comm of this.__comms) {\r\n            comm.__syncQueue(id, sab);\r\n        }\r\n    }\r\n    __unSyncQueue(id) {\r\n        for (const comm of this.__comms) {\r\n            comm.__unSyqncQueue(id);\r\n        }\r\n    }\r\n    syncData(dataType, data) {\r\n        for (const comm of this.__comms) {\r\n            comm.syncData(dataType, data);\r\n        }\r\n    }\r\n    unSyncData(dataType, data) {\r\n        for (const comm of this.__comms) {\r\n            comm.unSyncData(dataType, data);\r\n        }\r\n    }\r\n}\r\n","export {};\r\n","import { Queue } from \"../tools/Queue.js\";\r\nexport class QueueManager {\r\n    id;\r\n    onRun;\r\n    _manager;\r\n    getQueueKey;\r\n    __queueData = {};\r\n    constructor(id, onRun, _manager, getQueueKey = null) {\r\n        this.id = id;\r\n        this.onRun = onRun;\r\n        this._manager = _manager;\r\n        this.getQueueKey = getQueueKey;\r\n    }\r\n    __getQueueKey(data) {\r\n        if (this.getQueueKey !== null) {\r\n            return this.getQueueKey(data);\r\n        }\r\n        if (Array.isArray(data)) {\r\n            return data.toString();\r\n        }\r\n        if (typeof data == \"object\") {\r\n            return JSON.stringify(data);\r\n        }\r\n        return String(data);\r\n    }\r\n    __getQueueData(id) {\r\n        const queue = this.__queueData[id];\r\n        if (!queue) {\r\n            throw new Error(`Queue with id: ${id} does not exists.`);\r\n        }\r\n        return this.__queueData[id];\r\n    }\r\n    addQueue(queueId) {\r\n        const sab = new SharedArrayBuffer(4);\r\n        if (this.__queueData[queueId])\r\n            return false;\r\n        this.__queueData[queueId] = {\r\n            queue: new Queue(),\r\n            map: {},\r\n            stateSAB: sab,\r\n            state: new Uint32Array(sab),\r\n        };\r\n        const syncId = this._getSyncId(queueId);\r\n        this._manager.__syncQueue(syncId, sab);\r\n        return true;\r\n    }\r\n    _getSyncId(queueId) {\r\n        return `${this.id}-${queueId}`;\r\n    }\r\n    removeQueue(queueId) {\r\n        if (!this.__queueData[queueId])\r\n            return false;\r\n        delete this.__queueData[queueId];\r\n        const syncId = this._getSyncId(queueId);\r\n        this._manager.__unSyncQueue(syncId);\r\n        return true;\r\n    }\r\n    add(data, queueId = \"main\") {\r\n        const queueData = this.__getQueueData(queueId);\r\n        const queueKey = this.__getQueueKey(data);\r\n        if (queueData.map[queueKey])\r\n            return;\r\n        queueData.map[queueKey] = true;\r\n        queueData.queue.enqueue(data);\r\n    }\r\n    run(queueId = \"main\", filter) {\r\n        const reQueue = new Queue();\r\n        const newMap = {};\r\n        const queueData = this.__getQueueData(queueId);\r\n        const queue = queueData.queue;\r\n        const state = queueData.state;\r\n        const syncId = this._getSyncId(queueId);\r\n        while (true) {\r\n            const data = queue.dequeue();\r\n            if (!data)\r\n                break;\r\n            if (filter) {\r\n                const filterReturn = filter(data);\r\n                if (filterReturn == 0)\r\n                    continue;\r\n                if (filterReturn == 1) {\r\n                    newMap[this.__getQueueKey(data)] = true;\r\n                    reQueue.enqueue(data);\r\n                    continue;\r\n                }\r\n            }\r\n            Atomics.add(state, 0, 1);\r\n            this.onRun(data, syncId);\r\n        }\r\n        this.__queueData[queueId].map = {};\r\n        if (filter) {\r\n            this.__queueData[queueId].queue = queue;\r\n            this.__queueData[queueId].map = newMap;\r\n        }\r\n    }\r\n    runAndAwait(queueId = \"main\", filter) {\r\n        this.run(queueId, filter);\r\n        return this.awaitAll(queueId);\r\n    }\r\n    awaitAll(queueId = \"main\") {\r\n        const queueData = this.__getQueueData(queueId);\r\n        return new Promise((resolve, reject) => {\r\n            const inte = setInterval(() => {\r\n                if (Atomics.load(queueData.state, 0) == 0) {\r\n                    clearInterval(inte);\r\n                    resolve(true);\r\n                }\r\n            }, 1);\r\n        });\r\n    }\r\n    onDone(queueId = \"main\", run) {\r\n        const queueData = this.__getQueueData(queueId);\r\n        const inte = setInterval(() => {\r\n            if (Atomics.load(queueData.state, 0) == 0) {\r\n                clearInterval(inte);\r\n                run();\r\n            }\r\n        }, 1);\r\n    }\r\n    isDone(queueId = \"main\") {\r\n        const queueData = this.__getQueueData(queueId);\r\n        return Atomics.load(queueData.state, 0) == 0;\r\n    }\r\n}\r\n","export class SyncedQueue {\r\n    id;\r\n    sab;\r\n    states = new Uint32Array();\r\n    constructor(id, sab) {\r\n        this.id = id;\r\n        this.sab = sab;\r\n        this.states = new Uint32Array(sab);\r\n    }\r\n    addToCount(total = 1) {\r\n        Atomics.add(this.states, 0, total);\r\n    }\r\n    subtractFromCount(total = 1) {\r\n        Atomics.sub(this.states, 0, total);\r\n    }\r\n    getCount() {\r\n        return Atomics.load(this.states, 0);\r\n    }\r\n    isDone() {\r\n        return this.getCount() == 0;\r\n    }\r\n    onDone(onDone) {\r\n        const inte = setInterval(() => {\r\n            if (this.getCount() == 0) {\r\n                clearInterval(inte);\r\n                onDone();\r\n            }\r\n        }, 1);\r\n    }\r\n    wait() {\r\n        return new Promise((resolve, reject) => {\r\n            this.onDone(() => {\r\n                resolve(true);\r\n            });\r\n        });\r\n    }\r\n}\r\n","export const PromiseTasks = {\r\n    _waiting: (new Map()),\r\n    addPromiseTakss(tasksId, tasksRequestsId, onDone) {\r\n        let requestsMap = this._waiting.get(tasksId);\r\n        if (!requestsMap) {\r\n            requestsMap = new Map();\r\n            this._waiting.set(tasksId, requestsMap);\r\n        }\r\n        requestsMap.set(tasksRequestsId, onDone);\r\n    },\r\n    completePromiseTasks(tasksId, tasksRequestsId, data) {\r\n        let requestsMap = this._waiting.get(tasksId);\r\n        if (!requestsMap)\r\n            return;\r\n        const run = requestsMap.get(tasksRequestsId);\r\n        if (!run)\r\n            return;\r\n        run(data);\r\n    },\r\n};\r\n","export class Task {\r\n    name;\r\n    run;\r\n    mode;\r\n    constructor(name, run, mode) {\r\n        this.name = name;\r\n        this.run = run;\r\n        this.mode = mode;\r\n    }\r\n}\r\n","//constants\r\nimport { TCMessageHeaders, TCInternalMessages, TCDataSyncMessages, } from \"./Constants/Messages.js\";\r\n//classes\r\nimport { Task } from \"./Tasks/Tasks.js\";\r\nimport { CommManager } from \"./Manager/CommManager.js\";\r\nimport { CommBase } from \"./Comm/Comm.js\";\r\nimport { SyncedQueue } from \"./Queue/SyncedQueue.js\";\r\nimport { DataSync } from \"./Data/DataSync.js\";\r\nimport { PromiseTasks } from \"./Tasks/PromiseTasks.js\";\r\nexport const ThreadComm = {\r\n    threadNumber: 0,\r\n    threadName: \"unamed-threadcomm-thread\",\r\n    environment: \"browser\",\r\n    _comms: {},\r\n    _commManageras: {},\r\n    _tasks: {},\r\n    _queues: new Map(),\r\n    _onDataSync: {},\r\n    parent: new CommBase(\"\"),\r\n    __internal: {},\r\n    __initalized: false,\r\n    __expectedPorts: {},\r\n    async $INIT(threadName, threadParentName) {\r\n        this.threadName = threadName;\r\n        this.parent.name = threadParentName;\r\n        const port = await this.getWorkerPort();\r\n        this.parent.setPort(port);\r\n        this.__initalized = true;\r\n        this.addComm(this.parent);\r\n    },\r\n    getSyncedQueue(threadId, queueId) {\r\n        if (!this._queues.has(threadId))\r\n            return;\r\n        return this._queues.get(threadId)?.get(queueId);\r\n    },\r\n    addComm(comm) {\r\n        this._comms[comm.name] = comm;\r\n    },\r\n    createComm(name, mergeObject = {}) {\r\n        const newCom = Object.assign(new CommBase(name), mergeObject);\r\n        this._comms[name] = newCom;\r\n        return newCom;\r\n    },\r\n    createCommManager(data) {\r\n        const newCommManager = new CommManager(data);\r\n        this._commManageras[data.name] = newCommManager;\r\n        return newCommManager;\r\n    },\r\n    getComm(id) {\r\n        return this._comms[id];\r\n    },\r\n    getCommManager(id) {\r\n        return this._commManageras[id];\r\n    },\r\n    __throwError(message) {\r\n        throw new Error(`[ThreadComm] ${message}`);\r\n    },\r\n    async getWorkerPort() {\r\n        if (this.environment == \"browser\") {\r\n            return self;\r\n        }\r\n        if (this.environment == \"node\") {\r\n            //@ts-ignore\r\n            const { parentPort } = require(\"worker_threads\");\r\n            return parentPort;\r\n        }\r\n    },\r\n    __handleInternalMessage(data, event) {\r\n        //remove header\r\n        const headerId = data.shift();\r\n        //remove message\r\n        const messageId = data.shift();\r\n        this.__internal[headerId][messageId](data, event);\r\n    },\r\n    __isInternalMessage(data) {\r\n        return this.__internal[data[0]] !== undefined;\r\n    },\r\n    __handleTasksDone(tasksId, mode, threadId, tid, tasksData) {\r\n        if (mode == 1) {\r\n            const comm = this.getComm(threadId);\r\n            comm.sendMessage(TCMessageHeaders.internal, [\r\n                TCInternalMessages.completeTasks,\r\n                tasksId,\r\n                tid,\r\n                tasksData,\r\n            ]);\r\n        }\r\n        if (mode == 2) {\r\n            //complete queue\r\n            if (tid && threadId) {\r\n                const queue = this.getSyncedQueue(threadId, tid);\r\n                if (queue) {\r\n                    queue.subtractFromCount();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    async __handleTasksMessage(data) {\r\n        //remove header\r\n        data.shift();\r\n        //remove tasks id\r\n        const tasksId = data.shift();\r\n        //remove thread id\r\n        const threadId = data.shift();\r\n        //remove queue id\r\n        const mode = data.shift();\r\n        //remove queue id\r\n        const tid = data.shift();\r\n        const takss = this._tasks[tasksId];\r\n        if (takss.mode == \"async\") {\r\n            const tasksData = await this._tasks[tasksId].run(data[0]);\r\n            this.__handleTasksDone(tasksId, mode, threadId, tid, tasksData);\r\n        }\r\n        if (takss.mode == \"deffered\") {\r\n            await this._tasks[tasksId].run(data[0], (tasksData) => {\r\n                ThreadComm.__handleTasksDone(tasksId, mode, threadId, tid, tasksData);\r\n            });\r\n        }\r\n    },\r\n    __isTasks(data) {\r\n        return (data[0] == TCMessageHeaders.runTasks && this._tasks[data[1]] !== undefined);\r\n    },\r\n    async __handleTasksCheckMessage(data) {\r\n        //remove header\r\n        data.shift();\r\n        //remove tasks id\r\n        const tasksId = data.shift();\r\n        //remove thread id\r\n        const threadId = data.shift();\r\n        //remove promise id\r\n        const promiseId = data.shift();\r\n        const thread = this.getComm(threadId);\r\n        const takss = this._tasks[tasksId];\r\n        if (takss && thread) {\r\n            thread.sendMessage(TCMessageHeaders.internal, [\r\n                TCInternalMessages.checkTasksResult,\r\n                true,\r\n                promiseId,\r\n            ]);\r\n        }\r\n        if (!takss && thread) {\r\n            thread.sendMessage(TCMessageHeaders.internal, [\r\n                TCInternalMessages.checkTasksResult,\r\n                false,\r\n                promiseId,\r\n            ]);\r\n        }\r\n    },\r\n    __isTasksCheck(data) {\r\n        return data[0] == TCMessageHeaders.checkTasks;\r\n    },\r\n    registerTasks(id, run, mode = \"async\") {\r\n        const tasks = new Task(id, run, mode);\r\n        this._tasks[id] = tasks;\r\n        return tasks;\r\n    },\r\n    async __hanldeDataSyncMessage(data) {\r\n        //remove header\r\n        data.shift();\r\n        //remove queue id\r\n        const action = data.shift();\r\n        //remove tasks id\r\n        const dataTypeId = data.shift();\r\n        const dataSync = this._onDataSync[dataTypeId];\r\n        //get the sync data\r\n        const syncData = data.shift();\r\n        if (action == TCDataSyncMessages.SyncData) {\r\n            dataSync.sync(syncData);\r\n        }\r\n        if (action == TCDataSyncMessages.UnSyncData) {\r\n            dataSync.unSync(syncData);\r\n        }\r\n    },\r\n    __isDataSync(data) {\r\n        return data[0] == TCMessageHeaders.dataSync;\r\n    },\r\n    onDataSync(dataType, onSync, onUnSync) {\r\n        const sync = new DataSync();\r\n        if (onSync) {\r\n            sync.addOnSync(onSync);\r\n        }\r\n        if (onUnSync) {\r\n            sync.addOnUnSync(onUnSync);\r\n        }\r\n        this._onDataSync[dataType] = sync;\r\n        return sync;\r\n    },\r\n};\r\nif (\r\n//@ts-ignore\r\ntypeof process !== \"undefined\" &&\r\n    typeof Worker === \"undefined\" &&\r\n    typeof window === \"undefined\") {\r\n    ThreadComm.environment = \"node\";\r\n}\r\nconst internal = {};\r\nThreadComm.__internal[TCMessageHeaders.internal] = internal;\r\ninternal[TCInternalMessages.connectPort] = (data, event) => {\r\n    const threadName = data[0];\r\n    const threadManager = data[1];\r\n    let port;\r\n    if (ThreadComm.environment == \"browser\") {\r\n        port = event.ports[0];\r\n    }\r\n    else {\r\n        port = data[2];\r\n    }\r\n    if (threadManager == \"worker\") {\r\n        const comm = ThreadComm.getComm(threadName);\r\n        comm.setPort(port);\r\n    }\r\n    if (threadManager != \"worker\") {\r\n        const comm = ThreadComm.getCommManager(threadManager);\r\n        comm.addPort(port);\r\n    }\r\n};\r\ninternal[TCInternalMessages.IsReady] = (data) => {\r\n    const name = data[0];\r\n    const comm = ThreadComm.getComm(name);\r\n    if (!comm)\r\n        return;\r\n    comm.__ready = true;\r\n};\r\ninternal[TCInternalMessages.nameThread] = (data) => {\r\n    const name = data[0];\r\n    const number = data[1];\r\n    ThreadComm.threadName = name;\r\n    ThreadComm.threadNumber = number;\r\n};\r\ninternal[TCInternalMessages.syncQueue] = (data) => {\r\n    const threadName = data[0];\r\n    const queueId = data[1];\r\n    const queueSAB = data[2];\r\n    if (!ThreadComm._queues.has(threadName)) {\r\n        ThreadComm._queues.set(threadName, new Map());\r\n    }\r\n    //@ts-ignore\r\n    ThreadComm._queues\r\n        .get(threadName)\r\n        .set(queueId, new SyncedQueue(queueId, queueSAB));\r\n};\r\ninternal[TCInternalMessages.unSyncQueue] = (data) => {\r\n    const threadName = data[0];\r\n    const queueId = data[1];\r\n    if (!ThreadComm._queues.has(threadName)) {\r\n        return;\r\n    }\r\n    //@ts-ignore\r\n    ThreadComm._queues.get(threadName).delete(queueId);\r\n};\r\ninternal[TCInternalMessages.completeTasks] = (data) => {\r\n    const tasksId = data[0];\r\n    const requestsId = data[1];\r\n    const tasksData = data[2];\r\n    PromiseTasks.completePromiseTasks(tasksId, requestsId, tasksData);\r\n};\r\ninternal[TCInternalMessages.checkTasksResult] = (data) => {\r\n    const result = data[0];\r\n    const promiseId = data[1];\r\n    PromiseTasks.completePromiseTasks(\"tasks-check\", promiseId, result);\r\n};\r\n","export * from \"./ThreadComm.js\";\r\nexport * from \"./Comm/Comm.js\";\r\nexport * from \"./Data/DataSync.js\";\r\nexport * from \"./Manager/CommManager.js\";\r\nexport * from \"./Tasks/Tasks.js\";\r\nexport * from \"./Meta/Comm/Comm.types.js\";\r\n","class QueueNode {\r\n    data;\r\n    next;\r\n    constructor(data) {\r\n        this.data = data;\r\n    }\r\n}\r\n//test\r\nexport class Queue {\r\n    size = 0;\r\n    first;\r\n    last;\r\n    enqueue(data) {\r\n        const node = new QueueNode(data);\r\n        if (this.size == 0) {\r\n            this.first = node;\r\n            this.last = node;\r\n        }\r\n        else {\r\n            this.last.next = node;\r\n            this.last = node;\r\n        }\r\n        this.size++;\r\n    }\r\n    dequeue() {\r\n        if (this.size == 0)\r\n            return null;\r\n        if (!this.first)\r\n            return null;\r\n        let prevFirst = this.first;\r\n        this.first = prevFirst.next;\r\n        prevFirst.next = null;\r\n        this.size--;\r\n        return prevFirst.data;\r\n    }\r\n}\r\n","class VSVec3 {\r\n    x;\r\n    y;\r\n    z;\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    copy() {\r\n        return new VSVec3(this.x, this.y, this.z);\r\n    }\r\n    copyTo(vec3) {\r\n        vec3.x = this.x;\r\n        vec3.y = this.y;\r\n        vec3.z = this.z;\r\n    }\r\n    toString() {\r\n        return `${this.x}_${this.y}_${this.z}`;\r\n    }\r\n    multiply(vec3) {\r\n        this.x *= vec3.x;\r\n        this.y *= vec3.y;\r\n        this.z *= vec3.z;\r\n        return this;\r\n    }\r\n}\r\n//Objects\r\nexport class VoxelSpace {\r\n    data;\r\n    static simpleCubeHash(space) {\r\n        space._position.x =\r\n            (space._position.x >> space._boundsPower2.x) << space._boundsPower2.x;\r\n        space._position.y =\r\n            (space._position.y >> space._boundsPower2.y) << space._boundsPower2.y;\r\n        space._position.z =\r\n            (space._position.z >> space._boundsPower2.z) << space._boundsPower2.z;\r\n        return space._position;\r\n    }\r\n    static getPositionFromIndex(position, bounds, index) {\r\n        position.x = index % bounds.x >> 0;\r\n        position.y = (index / bounds.x) % bounds.y >> 0;\r\n        position.z = (index / (bounds.x * bounds.y)) >> 0;\r\n        return position;\r\n    }\r\n    static getIndex(position, bounds) {\r\n        return (position.x + position.y * bounds.x + position.z * bounds.z * bounds.y);\r\n    }\r\n    static WholeVec3 = new VSVec3(1, 1, 1);\r\n    static spatialHash(space, parentSpace, divisor = VoxelSpace.WholeVec3) {\r\n        const parentPosition = parentSpace.getPositionXYZ(space._position.x, space._position.y, space._position.z);\r\n        space._hashedPosition.x =\r\n            Math.abs(space._position.x - parentPosition.x) / divisor.x;\r\n        space._hashedPosition.y =\r\n            Math.abs(space._position.y - parentPosition.y) / divisor.y;\r\n        space._hashedPosition.z =\r\n            Math.abs(space._position.z - parentPosition.z) / divisor.z;\r\n        return space._hashedPosition;\r\n    }\r\n    static mapLocationToVec3(location, vector) {\r\n        location[1] = vector.x;\r\n        location[2] = vector.y;\r\n        location[3] = vector.z;\r\n    }\r\n    _location = [\"main\", 0, 0, 0];\r\n    _position = new VSVec3(0, 0, 0);\r\n    _hashedPosition = new VSVec3(0, 0, 0);\r\n    _bounds = new VSVec3(0, 0, 0);\r\n    _boundsPower2 = new VSVec3(0, 0, 0);\r\n    _boundsSet = false;\r\n    constructor(data) {\r\n        this.data = data;\r\n    }\r\n    getVolume() {\r\n        return this._bounds.x * this._bounds.y * this._bounds.z;\r\n    }\r\n    getArea() {\r\n        return this._bounds.x * this._bounds.z;\r\n    }\r\n    setXYZ(x, y, z) {\r\n        this._position.x = x;\r\n        this._position.y = y;\r\n        this._position.z = z;\r\n        this.getPosition();\r\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\r\n        return this;\r\n    }\r\n    setXZ(x, z) {\r\n        this._position.x = x;\r\n        this._position.z = z;\r\n        this.getPosition();\r\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\r\n        return this;\r\n    }\r\n    getLocation() {\r\n        this.data.getPosition(this);\r\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\r\n        return this._location;\r\n    }\r\n    getLocationXYZ(x, y, z) {\r\n        this.setXYZ(x, y, z);\r\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\r\n        return this._location;\r\n    }\r\n    setLocation(location) {\r\n        this.setXYZ(location[1], location[2], location[3]);\r\n        return this;\r\n    }\r\n    updateLoaction(location) {\r\n        this.setXYZ(location[1], location[2], location[3]);\r\n        location[1] = this._location[1];\r\n        location[2] = this._location[2];\r\n        location[3] = this._location[3];\r\n        return this;\r\n    }\r\n    setCubeBounds(bounds) {\r\n        if (this._boundsSet)\r\n            return;\r\n        this._boundsPower2.x = bounds.x;\r\n        this._boundsPower2.y = bounds.y;\r\n        this._boundsPower2.z = bounds.z;\r\n        this._bounds.x = 2 ** this._boundsPower2.x;\r\n        this._bounds.y = 2 ** this._boundsPower2.y;\r\n        this._bounds.z = 2 ** this._boundsPower2.z;\r\n        this._boundsSet = true;\r\n        return this;\r\n    }\r\n    setBounds(bounds) {\r\n        if (this._boundsSet)\r\n            return;\r\n        this._bounds.x = bounds.x;\r\n        this._bounds.y = bounds.y;\r\n        this._bounds.z = bounds.z;\r\n        this._boundsSet = true;\r\n        return this;\r\n    }\r\n    getPosition() {\r\n        return this.data.getPosition(this);\r\n    }\r\n    getPositionXYZ(x, y, z) {\r\n        return this.setXYZ(x, y, z).data.getPosition(this);\r\n    }\r\n    getPositionLocation(location) {\r\n        return this.setLocation(location).data.getPosition(this);\r\n    }\r\n    getIndex() {\r\n        return this.data.getIndex(this);\r\n    }\r\n    getIndexXYZ(x, y, z) {\r\n        return this.setXYZ(x, y, z).data.getIndex(this);\r\n    }\r\n    getIndexLocation(location) {\r\n        return this.setLocation(location).data.getIndex(this);\r\n    }\r\n    getPositionFromIndex(index) {\r\n        return this.data.getPostionFromIndex(this, index);\r\n    }\r\n    getKey() {\r\n        return `${this._position.x}_${this._position.y}_${this._position.z}`;\r\n    }\r\n    getKeyXYZ(x, y, z) {\r\n        return this.setXYZ(x, y, z).getKey();\r\n    }\r\n    getKeyLocation(location) {\r\n        return this.setLocation(location).getKey();\r\n    }\r\n}\r\n","export {};\r\n","import { VoxelSpace } from \"./Classes/VoxelSpace.js\";\r\nconst merge = (target, newObject) => {\r\n    return Object.assign(target, newObject);\r\n};\r\nexport const VoxelSpaces = {\r\n    zeroPointSpace: new VoxelSpace({\r\n        getPosition(space) {\r\n            return space._position;\r\n        },\r\n        getIndex() {\r\n            return 0;\r\n        },\r\n        getPostionFromIndex(space, index) {\r\n            return space._position;\r\n        },\r\n    }),\r\n    getVoxelSpaces() {\r\n        const regionSpace = merge(new VoxelSpace({\r\n            getPosition(space) {\r\n                return VoxelSpace.simpleCubeHash(space);\r\n            },\r\n            getIndex(space) {\r\n                return -Infinity;\r\n            },\r\n            getPostionFromIndex(space, index) {\r\n                return space._position;\r\n            },\r\n        }), {\r\n            chunkBounds: { x: 0, y: 0, z: 0 },\r\n            columnBounds: { x: 0, y: 0, z: 0 },\r\n            getChunkVolume() {\r\n                return this.chunkBounds.x * this.chunkBounds.y * this.chunkBounds.z;\r\n            },\r\n            getColumnVolume() {\r\n                return (this.columnBounds.x * this.columnBounds.y * this.columnBounds.z);\r\n            },\r\n        });\r\n        const columnSpace = new VoxelSpace({\r\n            getPosition(space) {\r\n                return VoxelSpace.simpleCubeHash(space);\r\n            },\r\n            getIndex(space) {\r\n                return VoxelSpace.getIndex(VoxelSpace.spatialHash(space, regionSpace, space._bounds), regionSpace.columnBounds);\r\n            },\r\n            getPostionFromIndex(space, index) {\r\n                return VoxelSpace.getPositionFromIndex(space._position, regionSpace.columnBounds, index).multiply(space._bounds);\r\n            },\r\n        });\r\n        const chunkSpace = merge(new VoxelSpace({\r\n            getPosition(space) {\r\n                return VoxelSpace.simpleCubeHash(space);\r\n            },\r\n            getIndex(space) {\r\n                const ry = (space._position.y >> regionSpace._boundsPower2.y) <<\r\n                    regionSpace._boundsPower2.y;\r\n                const cy = (space._position.y >> space._boundsPower2.y) <<\r\n                    space._boundsPower2.y;\r\n                return (cy - ry) / space._bounds.y;\r\n            },\r\n            getPostionFromIndex(space, index) {\r\n                return VoxelSpace.getPositionFromIndex(space._position, regionSpace.chunkBounds, index).multiply(space._bounds);\r\n            },\r\n        }), {\r\n            _regionPosition: { x: 0, y: 0, z: 0 },\r\n            getRegionPositonx() {\r\n                chunkSpace.getPosition();\r\n                return VoxelSpace.spatialHash(chunkSpace, regionSpace, chunkSpace._bounds);\r\n            },\r\n            getRegionPositonxXYZ(x, y, z) {\r\n                return chunkSpace.setXYZ(x, y, z).getRegionPositonx();\r\n            },\r\n            getRegionIndex() {\r\n                return VoxelSpace.getIndex(chunkSpace._hashedPosition, regionSpace.chunkBounds);\r\n            },\r\n            getRegionIndexXYZ(x, y, z) {\r\n                chunkSpace.getRegionPositonxXYZ(x, y, z);\r\n                return chunkSpace.getRegionIndex();\r\n            },\r\n        });\r\n        const voxelSpace = new VoxelSpace({\r\n            getPosition(space) {\r\n                VoxelSpace.spatialHash(space, chunkSpace);\r\n                space._position.x = space._hashedPosition.x;\r\n                space._position.y = space._hashedPosition.y;\r\n                space._position.z = space._hashedPosition.z;\r\n                return space._position;\r\n            },\r\n            getIndex(space) {\r\n                return VoxelSpace.getIndex(space._hashedPosition, space._bounds);\r\n            },\r\n            getPostionFromIndex(space, index) {\r\n                return VoxelSpace.getPositionFromIndex(space._position, chunkSpace._bounds, index);\r\n            },\r\n        });\r\n        return {\r\n            region: regionSpace,\r\n            column: columnSpace,\r\n            chunk: chunkSpace,\r\n            voxel: voxelSpace,\r\n            setDimensions(data) {\r\n                regionSpace.setCubeBounds(data.regions);\r\n                columnSpace.setCubeBounds(data.columns);\r\n                chunkSpace.setCubeBounds(data.chunks);\r\n                voxelSpace.setCubeBounds(data.chunks);\r\n                regionSpace.chunkBounds.x =\r\n                    regionSpace._bounds.x / chunkSpace._bounds.x;\r\n                regionSpace.chunkBounds.y =\r\n                    regionSpace._bounds.y / chunkSpace._bounds.y;\r\n                regionSpace.chunkBounds.z =\r\n                    regionSpace._bounds.z / chunkSpace._bounds.z;\r\n                regionSpace.columnBounds.x =\r\n                    regionSpace._bounds.x / columnSpace._bounds.x;\r\n                regionSpace.columnBounds.y =\r\n                    regionSpace._bounds.y / columnSpace._bounds.y;\r\n                regionSpace.columnBounds.z =\r\n                    regionSpace._bounds.z / columnSpace._bounds.z;\r\n            },\r\n        };\r\n    },\r\n    getZeroPointVoxelSpace(dimensions) {\r\n        const space = new VoxelSpace({\r\n            getPosition(space) {\r\n                VoxelSpace.spatialHash(space, VoxelSpaces.zeroPointSpace);\r\n                space._position.x = space._hashedPosition.x;\r\n                space._position.y = space._hashedPosition.y;\r\n                space._position.z = space._hashedPosition.z;\r\n                return space._position;\r\n            },\r\n            getIndex(space) {\r\n                return VoxelSpace.getIndex(space._hashedPosition, space._bounds);\r\n            },\r\n            getPostionFromIndex(space, index) {\r\n                return space._position;\r\n            },\r\n        });\r\n        space.setBounds(dimensions);\r\n        return space;\r\n    },\r\n};\r\n","export * from \"./VoxelSpaces.js\";\r\nexport * from \"./Types/VoxelSpaces.types.js\";\r\n"],"names":[],"sourceRoot":""}