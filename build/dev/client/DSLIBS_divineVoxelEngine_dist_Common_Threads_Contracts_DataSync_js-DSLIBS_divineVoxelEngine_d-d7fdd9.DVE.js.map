{"version":3,"file":"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-d7fdd9.DVE.js","mappings":";;;;;;;;;;;;;;AAA2D;AAC3D;AACA;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,mBAAmB,iEAAmB;AACtC;AACA,4BAA4B,sEAAwB;AACpD,mBAAmB,oEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,+DAA+D,iEAAmB;AAClF;AACA;AACA,4BAA4B,sEAAwB;AACpD,YAAY,oEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;ACxIyD;AACZ;AACtC;AACP;AACA,mBAAmB,sDAAU;AAC7B,KAAK;AACL;AACA,mBAAmB,kEAAgB;AACnC,KAAK;AACL;;;;;;;;;;;;;;;;ACT6D;AACtD,+BAA+B,sEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChB4E;AACf;AAC7D,qBAAqB,kEAAoB,WAAW,kEAAoB;AACxE;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO,yBAAyB,sEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,mGAAmG,kEAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uGAAuG,iEAAmB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,2EAA6B;AACtJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnLU;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9HsC;AACA;AACN;AACY;AACD;AACL;AACJ;;;;;;;;;;;;;;;ACN3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZmD;AACF;AAC1C;AACP;AACA,mBAAmB,4DAAS;AAC5B,KAAK;AACL;AACA,mBAAmB,0DAAQ;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;ACT2B;;;;;;;;;;;;;;;ACApB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBqC;AAC9B;AACP;AACA,6BAA6B,2DAAiB;AAC9C,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,0BAA0B,2DAAiB;AAC3C,0BAA0B,2DAAiB;AAC3C,KAAK;AACL,oBAAoB,2DAAiB;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;AC5B8E;AAC5B;AACD;AACI;AACE;AACE;AACF;AACG;AACA;AACL;AACyB;AACvE;AACP,gBAAgB,uFAAkB;AAClC,eAAe,0DAAS;AACxB,WAAW,gEAAY;AACvB,mBAAmB,kEAAa;AAChC,gBAAgB,mEAAU;AAC1B,iBAAiB,8DAAW;AAC5B,YAAY,8DAAW;AACvB,cAAc,2DAAQ;AACtB,eAAe,gEAAS;AACxB,gBAAgB,mEAAU;AAC1B,0BAA0B,wFAAoB;AAC9C;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACjXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC1BO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,2CAA2C,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5BsD;AACtD,qBAAqB,gEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;AChB+C;AAC/C,sBAAsB,gEAAgB;;;;;;;;;;;;;;;;ACDS;AAC/C,uBAAuB,gEAAgB;;;;;;;;;;;;;;;;;ACDC;AACK;AAC7C;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAA2C;AACnD,QAAQ,2EAA4B;AACpC,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC9CgD;AACG;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA4B;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAA0B;AAClC,4BAA4B,2EAA8B;AAC1D,eAAe,6EAAiC;AAChD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACrDsD;AAC/C,uBAAuB,gEAAgB;AACvC,6BAA6B,gEAAgB;;;;;;;;;;;;;;;;;;;ACFD;AACP;AACkB;AACN;AACxD;AACA;AACA;AACA,iBAAiB,6DAAQ;AACzB;AACA;AACA;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA,6BAA6B,wEAA6B;AAC1D;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,sFAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAoC;AACxD;AACA;AACA;AACA,gBAAgB,+EAAoC;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;;;;;;;;;;;;;;;;;;;;;;;ACrE6C;AACL;AAC+B;AACN;AACI;AACE;AACA;AAC/B;AAC/C,sBAAsB,iFAAa;AACnC,uBAAuB,mFAAc;AACrC,uBAAuB,mFAAc;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iBAAiB,sGAAuC;AACxD;AACA;AACA,SAAS;AACT;AACA,iBAAiB,sGAAuC;AACxD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,0BAA0B,sEAAyB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,8EAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,8EAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,+BAA+B,wEAA2B;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B,8EAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gFAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,gFAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,oEAAuB,EAAE,KAAK,oEAAuB,EAAE,MAAM,wEAA2B;AAClH;AACA;AACA,kCAAkC,6EAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,wEAA2B;AAC9D,mCAAmC,wEAA2B;AAC9D;AACA;AACA,oCAAoC,sFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,oEAAuB;AAClD;AACA,2BAA2B,oEAAuB;AAClD,gCAAgC,oEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAqC;AAClE;AACA;AACA,8BAA8B,uEAA0B;AACxD,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAkC;AAChE,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA,6BAA6B,6EAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uEAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+EAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACpRmD;AACoC;AAC5B;AACoB;AACxE,2BAA2B,oEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE;AACA;AACA;AACA,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD;AACA;AACA;AACA,yBAAyB,gGAA2B,EAAE,kHAAwC;AAC9F;AACA;AACA,eAAe,iHAAuC,kBAAkB,gGAA2B;AACnG;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDuF;AACzB;AACJ;AACY;AACT;AACA;AACH;AACI;AACC;AACL;AACa;AACZ;AACpD,uBAAuB,kEAAY;AAC1C;AACA,qBAAqB,sEAAa;AAClC,gCAAgC,sEAAa;AAC7C,6BAA6B,wEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAS;AACpB;AACA,2BAA2B,iHAAuC;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA;AACA;AACA,eAAe,0FAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA,4CAA4C,wFAAsB;AAClE;AACA,iCAAiC,2FAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAoB;AACnC;AACA;AACA,2BAA2B,4EAAoB;AAC/C;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,qFAAmB,EAAE,sEAAgB,CAAC,qFAAmB;AACvH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,wFAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,mBAAmB,8FAAqC,UAAU,uFAAqB,EAAE,sEAAgB,CAAC,uFAAqB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,sFAAoB,EAAE,sEAAgB,CAAC,sFAAoB;AACzH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,sFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,wFAAsB,EAAE,sEAAgB,CAAC,wFAAsB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,gCAAgC,6FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+FAAsC;AACzD;AACA,eAAe,+FAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7TA;AACqE;AACF;AACK;AACE;AACT;AAC1D,4BAA4B,6EAAuB;AAC1D,WAAW,qEAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAgC;AACxC,sBAAsB,iFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACnEA;AACqE;AACG;AACF;AACH;AAC5D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB,GAAG,6EAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnEA;AACqE;AAClB;AACc;AAC1D;AACP,4BAA4B,4DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,cAAc;AACd;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC,6FAAqC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AClFA;AACqE;AACG;AACF;AAC/D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA","sources":["webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Classes/TagManagerBase.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/DivineBinaryTags.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/RemoteTagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/TagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/DBTSchema.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/Util.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Util/DBTUtil.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/index.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/AsyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/SyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Hooks.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/DataSync.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/ChunkTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/VoxelTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/WorldDataTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Util/CardinalNeighbors.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataHooks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Light/LightByte.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Register/Register.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelPalette.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelReader.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Chunk/ChunkTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Column/ColumnTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Dimensions/DimensionsRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionHeaderRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldPainter.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/DataToolBase.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/LocationBoundTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/DataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ChunkDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ColumnDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/HeightMapTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/RegionDataTool.js"],"sourcesContent":["import { DBTUtil, TagNodeTypes } from \"../Util/DBTUtil.js\";\r\nconst TagIndexData = [0, 0, 0, 0];\r\nconst getIndexData = (data, indexBufferIndex) => {\r\n    TagIndexData[0] = data.getUint32(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\r\n    TagIndexData[1] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    TagIndexData[2] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    TagIndexData[3] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    return TagIndexData;\r\n};\r\nexport class TagManagerBase {\r\n    id;\r\n    byteOffSet = 0;\r\n    tagSize = 0;\r\n    tagIndexes = 0;\r\n    data = new DataView(new ArrayBuffer(0));\r\n    indexMap = new Map();\r\n    index = new DataView(new ArrayBuffer(0));\r\n    constructor(id) {\r\n        this.id = id;\r\n    }\r\n    setBuffer(data) {\r\n        if (data instanceof DataView) {\r\n            this.data = data;\r\n            return;\r\n        }\r\n        this.data = new DataView(data);\r\n    }\r\n    getBuffer() {\r\n        if (this.data instanceof DataView) {\r\n            return this.data.buffer;\r\n        }\r\n        return this.data;\r\n    }\r\n    setTagIndex(index) {\r\n        this.byteOffSet = index * this.tagSize;\r\n    }\r\n    getTag(id) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.boolean ||\r\n            indexData[3] == TagNodeTypes.number) {\r\n            return DBTUtil.getBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], indexData[2]);\r\n        }\r\n        if (indexData[3] == TagNodeTypes.typedNumber) {\r\n            return DBTUtil.getTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2]);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    setTag(id, value) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.boolean ||\r\n            indexData[3] == TagNodeTypes.number) {\r\n            this.data.setUint8(indexData[0] + this.byteOffSet, DBTUtil.setBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], value, indexData[2]));\r\n            return true;\r\n        }\r\n        if (indexData[3] == TagNodeTypes.typedNumber) {\r\n            DBTUtil.setTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2], value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getArrayTagValue(id, index) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return DBTUtil.getTypedNumber(this.data, indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2]);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    /**## getArrayTagByteIndex\r\n     *  Get the actual byte index for the provided index of the array.\r\n     * @param id\r\n     * @param index\r\n     * @returns\r\n     */\r\n    getArrayTagByteIndex(id, index) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return (indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]));\r\n        }\r\n        return -Infinity;\r\n    }\r\n    setArrayTagValue(id, index, value) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return DBTUtil.setTypedNumber(this.data, indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2], value);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    loopThroughTags(run) {\r\n        this.indexMap.forEach((i, id) => {\r\n            run(id, this.getTag(id));\r\n        });\r\n    }\r\n    loopThroughIndex(run) {\r\n        this.indexMap.forEach((index, id) => {\r\n            const indexData = getIndexData(this.index, index);\r\n            run(indexData);\r\n        });\r\n    }\r\n    loopThroughAllIndexTags(run) {\r\n        for (let index = 0; index < this.tagIndexes; index++) {\r\n            this.setTagIndex(index);\r\n            this.indexMap.forEach((i, id) => {\r\n                run(id, this.getTag(id), index);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import { RemoteTagManager } from \"./RemoteTagManager.js\";\r\nimport { TagManager } from \"./TagManager.js\";\r\nexport const DivineBinaryTags = {\r\n    createTagManager(id) {\r\n        return new TagManager(id);\r\n    },\r\n    createRemoteTagManager(id) {\r\n        return new RemoteTagManager(id);\r\n    },\r\n};\r\n","import { TagManagerBase } from \"./Classes/TagManagerBase.js\";\r\nexport class RemoteTagManager extends TagManagerBase {\r\n    id;\r\n    initData;\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    $INIT(data) {\r\n        this.data = new DataView(data.buffer);\r\n        this.index = new DataView(data.indexBuffer);\r\n        this.indexMap = data.indexMap;\r\n        this.tagIndexes = data.totalIndexes;\r\n        this.tagSize = data.tagSize;\r\n        this.initData = data;\r\n    }\r\n}\r\n","import { DBTUtil, TagNodeTypes, NumberTypeRecord } from \"./Util/DBTUtil.js\";\r\nimport { TagManagerBase } from \"./Classes/TagManagerBase.js\";\r\nconst TagIndexSize = DBTUtil.getTypedSize(\"32ui\") + DBTUtil.getTypedSize(\"8ui\") * 3;\r\nconst setIndexData = (data, indexBufferIndex, byteIndex, bitOffSet, bitSize, type) => {\r\n    data.setUint32(indexBufferIndex, byteIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\r\n    data.setUint8(indexBufferIndex, bitOffSet);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    data.setUint8(indexBufferIndex, bitSize);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    data.setUint8(indexBufferIndex, type);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    return indexBufferIndex;\r\n};\r\nexport class TagManager extends TagManagerBase {\r\n    id;\r\n    schema = new Map();\r\n    initData = {};\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    registerTag(tagData) {\r\n        this.schema.set(tagData.id, tagData);\r\n    }\r\n    $INIT(initData) {\r\n        /*\r\n    [Process Tags]\r\n    */\r\n        const headers = new Map();\r\n        const booleans = [];\r\n        const numbers = [];\r\n        const typedNumbers = new Map();\r\n        const typedNumbersArrays = new Map();\r\n        this.schema.forEach((tag) => {\r\n            if (tag.type == \"header\") {\r\n                let tags = headers.get(tag.numberType);\r\n                if (!tags) {\r\n                    tags = [];\r\n                    headers.set(tag.numberType, tags);\r\n                }\r\n                tags.push(tag);\r\n            }\r\n            if (tag.type == \"boolean\") {\r\n                booleans.push(tag);\r\n            }\r\n            if (tag.type == \"number\") {\r\n                const range = tag.range;\r\n                const bitSize = DBTUtil.calculateBitsNeeded(range[0], range[1]);\r\n                numbers[bitSize] ??= [];\r\n                numbers[bitSize].push(tag);\r\n            }\r\n            if (tag.type == \"typed-number\") {\r\n                let tags = typedNumbers.get(tag.numberType);\r\n                if (!tags) {\r\n                    tags = [];\r\n                    typedNumbers.set(tag.numberType, tags);\r\n                }\r\n                tags.push(tag);\r\n            }\r\n            if (tag.type == \"typed-number-array\") {\r\n                let arrayTags = typedNumbersArrays.get(tag.numberType);\r\n                if (!arrayTags) {\r\n                    arrayTags = [];\r\n                    typedNumbersArrays.set(tag.numberType, arrayTags);\r\n                }\r\n                arrayTags.push(tag);\r\n            }\r\n        });\r\n        /*\r\n    [Build Index]\r\n    */\r\n        const indexSize = this.schema.size * TagIndexSize;\r\n        let indexBuffer = new ArrayBuffer(indexSize);\r\n        if (initData?.indexBufferMode == \"shared\") {\r\n            indexBuffer = new SharedArrayBuffer(indexSize);\r\n        }\r\n        const index = new DataView(indexBuffer);\r\n        this.index = index;\r\n        let indexBufferIndex = 0;\r\n        let byteIndex = 0;\r\n        let bitIndex = 0;\r\n        let bitSize = 1;\r\n        /*\r\n    [Headers]\r\n    */\r\n        headers.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\r\n                byteIndex += byteSise;\r\n            }\r\n        });\r\n        /*\r\n    [Booleans]\r\n    */\r\n        bitSize = 1;\r\n        for (let i = 0; i < booleans.length; i++) {\r\n            const bool = booleans[i];\r\n            this.indexMap.set(bool.id, indexBufferIndex);\r\n            indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.boolean);\r\n            bitIndex++;\r\n            if (bitIndex >= 8) {\r\n                byteIndex++;\r\n                bitIndex = 0;\r\n            }\r\n        }\r\n        /*\r\n    [Ranged Numbers]\r\n    */\r\n        byteIndex++;\r\n        bitIndex = 0;\r\n        let cachedBitSize = 0;\r\n        numbers.forEach((tags, bitS) => {\r\n            bitSize = bitS;\r\n            if (cachedBitSize != bitSize) {\r\n                byteIndex++;\r\n                bitIndex = 0;\r\n            }\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.number);\r\n                bitIndex += bitSize;\r\n                if (bitIndex >= 8) {\r\n                    byteIndex++;\r\n                    bitIndex = 0;\r\n                }\r\n            }\r\n        });\r\n        /*\r\n    [Typed Numbers]\r\n    */\r\n        bitIndex = 0;\r\n        byteIndex++;\r\n        typedNumbers.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\r\n                byteIndex += byteSise;\r\n            }\r\n        });\r\n        /*\r\n    [Typed Numbers Arrays]\r\n    */\r\n        byteIndex++;\r\n        typedNumbersArrays.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumberArray);\r\n                byteIndex += byteSise * tag.length;\r\n            }\r\n        });\r\n        /*\r\n    [Create Remote Tag Manager Data]\r\n    */\r\n        let numberOfIndexes = 1;\r\n        if (initData?.numberOfIndexes) {\r\n            numberOfIndexes = initData.numberOfIndexes;\r\n        }\r\n        this.tagIndexes = numberOfIndexes;\r\n        this.tagSize = byteIndex;\r\n        const remoteData = {\r\n            bufferSize: byteIndex * numberOfIndexes,\r\n            buffer: new ArrayBuffer(0),\r\n            indexBuffer: indexBuffer,\r\n            indexMap: this.indexMap,\r\n            tagSize: this.tagSize,\r\n            totalIndexes: numberOfIndexes,\r\n        };\r\n        this.initData = remoteData;\r\n        return remoteData;\r\n    }\r\n}\r\n","export {};\r\n","export {};\r\n","export const TagNodeTypes = {\r\n    boolean: 0,\r\n    number: 1,\r\n    typedNumber: 2,\r\n    typedNumberArray: 3,\r\n};\r\nconst NumberTypeByteSize = {\r\n    \"8ui\": 1,\r\n    \"8i\": 1,\r\n    \"16ui\": 2,\r\n    \"16i\": 2,\r\n    \"32ui\": 4,\r\n    \"32i\": 4,\r\n    \"32f\": 4,\r\n    \"64f\": 8,\r\n    \"64i\": 8,\r\n    \"64ui\": 8,\r\n};\r\nexport const NumberTypeRecord = {\r\n    \"8ui\": 0,\r\n    \"8i\": 1,\r\n    \"16ui\": 2,\r\n    \"16i\": 3,\r\n    \"32ui\": 4,\r\n    \"32i\": 5,\r\n    \"32f\": 6,\r\n    \"64f\": 7,\r\n    \"64i\": 8,\r\n    \"64ui\": 9,\r\n};\r\nexport const NumberTypeMap = {};\r\nfor (const key of Object.keys(NumberTypeRecord)) {\r\n    //@ts-ignore\r\n    NumberTypeMap[Number(NumberTypeRecord[key])] = key;\r\n}\r\nconst TypedNumberSetFunctions = {\r\n    \"8ui\": (data, index, value) => {\r\n        data.setUint8(index, value);\r\n    },\r\n    \"8i\": (data, index, value) => {\r\n        data.setInt8(index, value);\r\n    },\r\n    \"16ui\": (data, index, value) => {\r\n        data.setUint16(index, value);\r\n    },\r\n    \"16i\": (data, index, value) => {\r\n        data.setInt16(index, value);\r\n    },\r\n    \"32ui\": (data, index, value) => {\r\n        data.setUint32(index, value);\r\n    },\r\n    \"32i\": (data, index, value) => {\r\n        data.setInt32(index, value);\r\n    },\r\n    \"32f\": (data, index, value) => {\r\n        data.setFloat32(index, value);\r\n    },\r\n    \"64f\": (data, index, value) => {\r\n        data.setFloat64(index, value);\r\n    },\r\n    \"64i\": (data, index, value) => {\r\n        data.setBigUint64(index, BigInt(value));\r\n    },\r\n    \"64ui\": (data, index, value) => {\r\n        data.setBigUint64(index, BigInt(value));\r\n    },\r\n};\r\nconst TypedNumberGetFunctions = {\r\n    \"8ui\": (data, index) => {\r\n        return data.getUint8(index);\r\n    },\r\n    \"8i\": (data, index) => {\r\n        return data.getInt8(index);\r\n    },\r\n    \"16ui\": (data, index) => {\r\n        return data.getUint16(index);\r\n    },\r\n    \"16i\": (data, index) => {\r\n        return data.getInt16(index);\r\n    },\r\n    \"32ui\": (data, index) => {\r\n        return data.getUint32(index);\r\n    },\r\n    \"32i\": (data, index) => {\r\n        return data.getInt32(index);\r\n    },\r\n    \"32f\": (data, index) => {\r\n        return data.getFloat32(index);\r\n    },\r\n    \"64f\": (data, index) => {\r\n        return data.getFloat64(index);\r\n    },\r\n    \"64i\": (data, index) => {\r\n        return Number(data.getBigUint64(index));\r\n    },\r\n    \"64ui\": (data, index) => {\r\n        return Number(data.getBigUint64(index));\r\n    },\r\n};\r\nexport const DBTUtil = {\r\n    setTypedNumber(data, index, numberType, value) {\r\n        TypedNumberSetFunctions[NumberTypeMap[numberType]](data, index, value);\r\n    },\r\n    getTypedNumber(data, index, numberType) {\r\n        return TypedNumberGetFunctions[NumberTypeMap[numberType]](data, index);\r\n    },\r\n    calculateBitsNeeded(min, max) {\r\n        let range = max - min;\r\n        return Math.ceil(Math.log2(range));\r\n    },\r\n    getTypedSize(type) {\r\n        return NumberTypeByteSize[type];\r\n    },\r\n    getTypedSizeFromNumber(t) {\r\n        return NumberTypeByteSize[NumberTypeMap[t]];\r\n    },\r\n    getBitValue(data, index, bitSize) {\r\n        index *= bitSize;\r\n        const mask = 2 ** bitSize - 1;\r\n        return ((mask << index) & data) >>> index;\r\n    },\r\n    setBitValue(data, index, value, bitSize) {\r\n        index *= bitSize;\r\n        const mask = 2 ** bitSize - 1;\r\n        return (data & ~(mask << index)) | ((value & mask) << index);\r\n    },\r\n};\r\n","export * from \"./DivineBinaryTags.js\";\r\nexport * from \"./RemoteTagManager.js\";\r\nexport * from \"./TagManager.js\";\r\nexport * from \"./Classes/TagManagerBase.js\";\r\nexport * from \"./Types/DBTSchema.types.js\";\r\nexport * from \"./Types/Util.types.js\";\r\nexport * from \"./Util/DBTUtil.js\";\r\n","export class AsyncHook {\r\n    _onRun = [];\r\n    async run(data) {\r\n        let returnData = false;\r\n        for (const run of this._onRun) {\r\n            returnData = await run(data);\r\n        }\r\n        return returnData;\r\n    }\r\n    addToRun(run) {\r\n        this._onRun.push(run);\r\n    }\r\n}\r\n","export class SyncHook {\r\n    _onRun = [];\r\n    run(data) {\r\n        let returnData = false;\r\n        for (const run of this._onRun) {\r\n            returnData = run(data);\r\n        }\r\n        return returnData;\r\n    }\r\n    addToRun(run) {\r\n        this._onRun.push(run);\r\n    }\r\n}\r\n","import { AsyncHook } from \"./Classes/AsyncHook.js\";\r\nimport { SyncHook } from \"./Classes/SyncHook.js\";\r\nexport const Hooks = {\r\n    getAsyncHook() {\r\n        return new AsyncHook();\r\n    },\r\n    getSyncHook() {\r\n        return new SyncHook();\r\n    },\r\n};\r\n","export * from \"./Hooks.js\";\r\n","export const DataSyncTypes = {\r\n    chunk: 0,\r\n    column: 1,\r\n    region: 2,\r\n    regionHeader: 2,\r\n    voxelPalette: 3,\r\n    voxelTags: 4,\r\n    materials: 4,\r\n    colliders: 4,\r\n    dimesnion: 5,\r\n    chunkTags: 6,\r\n    columnTags: 7,\r\n    regionTags: 8,\r\n    registerStringMap: 0,\r\n};\r\nlet index = 0;\r\nfor (const key of Object.keys(DataSyncTypes)) {\r\n    DataSyncTypes[key] = index;\r\n    index++;\r\n}\r\n","export const ChunkTagIDs = {\r\n    minHeight: \"#dve_min_height\",\r\n    maxHeight: \"#dve_max_height\",\r\n    heightMap: \"#dve_height_map\",\r\n    voxelIDSegment: \"#dve_voxel_id\",\r\n    voxelLightSegment: \"#dve_voxel_light\",\r\n    voxelStateSegment: \"#dve_voxel_state\",\r\n    voxelSecondaryIDSegment: \"#dve_voxel_secondary_id\",\r\n};\r\n","export const VoxelTagIDs = {\r\n    substance: \"#dve_substance\",\r\n    shapeID: \"#dve_shape_id\",\r\n    material: \"#dve_material\",\r\n    hardness: \"#dve_hardness\",\r\n    colliderID: \"#dve_collider_id\",\r\n    checkCollisions: \"#dve_check_collisions\",\r\n    isLightSource: \"#dve_is_light_source\",\r\n    lightValue: \"#dve_light_value\",\r\n    isRich: \"#dve_is_rich\",\r\n};\r\n","export const WorldDataTagIDs = {\r\n    header: \"#dve_header\",\r\n    dataType: \"#dve_data_type\",\r\n    dimensionId: \"#dve_dimension_id\",\r\n    positionX: \"#dve_p_x\",\r\n    positionY: \"#dve_p_y\",\r\n    positionZ: \"#dve_p_z\",\r\n};\r\n","export const $3dMooreNeighborhood = [];\r\nexport const $2dMooreNeighborhood = [\r\n    [0, 0],\r\n    [1, 0],\r\n    [0, 1],\r\n    [1, 1],\r\n    [-1, 0],\r\n    [0, -1],\r\n    [-1, -1],\r\n    [1, -1],\r\n    [-1, 1],\r\n];\r\nexport const $3dCardinalNeighbors = [\r\n    [0, 1, 0],\r\n    [0, -1, 0],\r\n    [1, 0, 0],\r\n    [-1, 0, 0],\r\n    [0, 0, -1],\r\n    [0, 0, 1],\r\n];\r\nfor (let y = -1; y < 2; y++) {\r\n    for (const n of $2dMooreNeighborhood) {\r\n        $3dMooreNeighborhood.push([n[0], y, n[1]]);\r\n    }\r\n}\r\n","import { Hooks } from \"divine-hooks\";\r\nexport const DataHooks = {\r\n    dimension: {\r\n        onRegisterDimension: Hooks.getSyncHook(),\r\n    },\r\n    chunk: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    column: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    region: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    paint: {\r\n        onAddToRGBUpdate: Hooks.getSyncHook(),\r\n        onRichVoxelPaint: Hooks.getSyncHook(),\r\n    },\r\n    settingsSynced: Hooks.getSyncHook(),\r\n};\r\n","import { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\r\nimport { Register } from \"./Register/Register.js\";\r\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\r\nimport { WorldBounds } from \"./World/WorldBounds.js\";\r\nimport { WorldPainter } from \"./World/WorldPainter.js\";\r\nimport { WorldRegister } from \"./World/WorldRegister.js\";\r\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\r\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\r\nimport { RegionTags } from \"./World/Region/RegionTags.js\";\r\nimport { WorldSpaces } from \"./World/WorldSpaces.js\";\r\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\r\nexport const DataManager = {\r\n    dimensions: DimensionsRegister,\r\n    voxelTags: VoxelTags,\r\n    world: WorldPainter,\r\n    worldRegister: WorldRegister,\r\n    columnTags: ColumnTags,\r\n    worldBounds: WorldBounds,\r\n    spaces: WorldSpaces,\r\n    register: Register,\r\n    chunkTags: ChunkTags,\r\n    regionTags: RegionTags,\r\n    regionHeaderReigster: RegionHeaderRegister,\r\n};\r\n","/**# Light Byte\r\n * ---\r\n * Used to decode light color info.\r\n */\r\nexport const LightData = {\r\n    SRS: 2,\r\n    _lightValues: [0, 0, 0, 0],\r\n    getS(value) {\r\n        return value & 0xf;\r\n    },\r\n    getR(value) {\r\n        return (value & (0xf << 4)) >> 4;\r\n    },\r\n    getG(value) {\r\n        return (value & (0xf << 8)) >> 8;\r\n    },\r\n    getB(value) {\r\n        return (value & (0xf << 12)) >> 12;\r\n    },\r\n    setS(value, sl) {\r\n        return (sl & ~0xf) | value;\r\n    },\r\n    setR(value, sl) {\r\n        return (sl & ~(0xf << 4)) | (value << 4);\r\n    },\r\n    setG(value, sl) {\r\n        return (sl & ~(0xf << 8)) | (value << 8);\r\n    },\r\n    setB(value, sl) {\r\n        return (sl & ~(0xf << 12)) | (value << 12);\r\n    },\r\n    removeS(sl) {\r\n        return this.setS(0, sl);\r\n    },\r\n    hasRGBLight(sl) {\r\n        if (sl <= 0)\r\n            return false;\r\n        if (this.getR(sl) > 0)\r\n            return true;\r\n        if (this.getG(sl) > 0)\r\n            return true;\r\n        if (this.getB(sl) > 0)\r\n            return true;\r\n        return false;\r\n    },\r\n    hasSunLight(sl) {\r\n        if (sl <= 0)\r\n            return false;\r\n        if (this.getS(sl) > 0)\r\n            return true;\r\n        return false;\r\n    },\r\n    mixLight(l1, l2) {\r\n        const s1 = this.getS(l1);\r\n        const s2 = this.getS(l2);\r\n        const s = s1 < s2 ? s2 : s1;\r\n        const r1 = this.getR(l1);\r\n        const r2 = this.getR(l2);\r\n        const r = r1 < r2 ? r2 : r1;\r\n        const g1 = this.getG(l1);\r\n        const g2 = this.getG(l2);\r\n        const g = g1 < g2 ? g2 : g1;\r\n        const b1 = this.getB(l1);\r\n        const b2 = this.getB(l2);\r\n        const b = b1 < b2 ? b2 : b1;\r\n        let nl = this.setS(s, 0);\r\n        nl = this.setR(r, nl);\r\n        nl = this.setG(g, nl);\r\n        nl = this.setB(b, nl);\r\n        return nl;\r\n    },\r\n    getRGB(sl) {\r\n        if (sl < 0)\r\n            return 0;\r\n        return (sl & 0xfff0) >> 4;\r\n    },\r\n    setRGB(value, sl) {\r\n        if (sl < 0)\r\n            return 0;\r\n        return (sl & ~0xfff0) | (value << 4);\r\n    },\r\n    decodeLightFromVoxelData(voxelData) {\r\n        return (voxelData & (0xffff << 0)) >> 0;\r\n    },\r\n    encodeLightIntoVoxelData(voxelData, encodedLight) {\r\n        return (voxelData & ~(0xffff << 0)) | (encodedLight << 0);\r\n    },\r\n    /**# Set Light Values\r\n     * ---\r\n     * Give an array of light values it will return an encoded light number.\r\n     * @param values\r\n     */\r\n    setLightValues(values) {\r\n        let value = this.setS(values[0], 0);\r\n        value = this.setR(values[1], value);\r\n        value = this.setG(values[2], value);\r\n        return this.setB(values[3], value);\r\n    },\r\n    /**# Get Light Values\r\n     * ---\r\n     * Given an encoded light number it will return an array of its values.\r\n     * - 0: Sun Light\r\n     * - 1: Red Light\r\n     * - 2: Green Light\r\n     * - 3: Blue Light\r\n     * @param value\r\n     */\r\n    getLightValues(value) {\r\n        this._lightValues[0] = this.getS(value);\r\n        this._lightValues[1] = this.getR(value);\r\n        this._lightValues[2] = this.getG(value);\r\n        this._lightValues[3] = this.getB(value);\r\n        return this._lightValues;\r\n    },\r\n    /**# Is Less Than For RGB Remove\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light remove.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForRGBRemove(n1, n2) {\r\n        let r1 = this.getR(n1);\r\n        let g1 = this.getG(n1);\r\n        let b1 = this.getB(n1);\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 < r2 || g1 < g2 || b1 < b2;\r\n    },\r\n    /**# Is Less Than For RGB Add\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light add.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForRGBAdd(n1, n2) {\r\n        let r1 = this.getR(n1) + 2;\r\n        let g1 = this.getG(n1) + 2;\r\n        let b1 = this.getB(n1) + 2;\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 <= r2 || g1 <= g2 || b1 <= b2;\r\n    },\r\n    /**# Is Greater Or Equal Than For RGB Remove\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light remove.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isGreaterOrEqualThanForRGBRemove(n1, n2) {\r\n        let r1 = this.getR(n1);\r\n        let g1 = this.getG(n1);\r\n        let b1 = this.getB(n1);\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 >= r2 || g1 >= g2 || b1 >= b2;\r\n    },\r\n    /**# Get Minus One For RGB\r\n     * ---\r\n     * Returns the RGB light values minus one.\r\n     * @param sl - source light value\r\n     */\r\n    getMinusOneForRGB(sl, nl) {\r\n        let s = this.getS(nl);\r\n        let r = this.getR(sl) - 1;\r\n        if (r < 0)\r\n            r = 0;\r\n        let rn = this.getR(nl);\r\n        if (r < rn) {\r\n            r = rn;\r\n        }\r\n        let g = this.getG(sl) - 1;\r\n        if (g < 0)\r\n            g = 0;\r\n        let gn = this.getG(nl);\r\n        if (g < gn) {\r\n            g = gn;\r\n        }\r\n        let b = this.getB(sl) - 1;\r\n        if (b < 0)\r\n            b = 0;\r\n        let bn = this.getB(nl);\r\n        if (b < bn) {\r\n            b = bn;\r\n        }\r\n        let bv = 0;\r\n        bv = this.setS(s, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Remove RGB Light\r\n     * ---\r\n     * Removes all RGB light from an encoded light value.\r\n     * @param sl - source light value\r\n     */\r\n    removeRGBLight(sl) {\r\n        let s = this.getS(sl);\r\n        let bv = 0;\r\n        bv = this.setR(0, bv);\r\n        bv = this.setG(0, bv);\r\n        bv = this.setB(0, bv);\r\n        bv = this.setS(s, bv);\r\n        return bv;\r\n    },\r\n    /**# Get Full Sun Light\r\n     * --\r\n     * Alters the encoded light number passed to it to give it full sun light.\r\n     * @param sl - source light value\r\n     */\r\n    getFullSunLight(sl) {\r\n        return sl | 0b1111;\r\n    },\r\n    /**# Is Less Than For Sun Add\r\n     * ---\r\n     * Used to calculate sun light addition.\r\n     * Used to check all neighbors expect down.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForSunAdd(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    /**# Is Less Than For Sun Add Down\r\n     *\r\n     * Used to calculate sun light addition.\r\n     * Used to check only the down neighbor.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForSunAddDown(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        if (sl2 == 0xf) {\r\n            return sl1 < sl2;\r\n        }\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    isLessThanForSunAddUp(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        if (sl1 == sl2)\r\n            return false;\r\n        if (sl2 == 0xf || sl1 == 0xf)\r\n            return false;\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    /**# Get Sun Light For Under Voxel\r\n     * ---\r\n     * Gets the sun light value for sun light addition when setting the\r\n     * down neighbor.\r\n     * @param currentVoxel\r\n     */\r\n    getSunLightForUnderVoxel(sl, nl) {\r\n        let s = this.getS(sl);\r\n        let sn = this.getS(nl);\r\n        if (s == 15) {\r\n            sn = s;\r\n        }\r\n        if (s < 15) {\r\n            sn = s - this.SRS;\r\n        }\r\n        let r = this.getR(nl);\r\n        let g = this.getG(nl);\r\n        let b = this.getB(nl);\r\n        let bv = 0;\r\n        bv = this.setS(sn, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Get Minus One For Sun\r\n     * ---\r\n     * Returns the sun light level passed to it minus one.\r\n     * Used for sun light addition on all neighbors expect the down one.\r\n     * @param sl - source light value\r\n     */\r\n    getMinusOneForSun(sl, nl) {\r\n        let s = this.getS(sl) - this.SRS;\r\n        if (s < 0)\r\n            s = 0;\r\n        let sn = this.getS(nl);\r\n        if (s < sn) {\r\n            s = sn;\r\n        }\r\n        let r = this.getR(nl);\r\n        let g = this.getG(nl);\r\n        let b = this.getB(nl);\r\n        let bv = 0;\r\n        bv = this.setS(s, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Is Less Than For Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    isLessThanForSunRemove(n1, sl) {\r\n        let s1 = this.getS(n1);\r\n        let s2 = this.getS(sl);\r\n        return s1 < s2;\r\n    },\r\n    /**# Is Greater Or Equal Than For Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    isGreaterOrEqualThanForSunRemove(n1, sl) {\r\n        let s1 = this.getS(n1);\r\n        let s2 = this.getS(sl);\r\n        return s1 >= s2;\r\n    },\r\n    /**# Sun Light Compare For Down Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal in the downward direction only.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    sunLightCompareForDownSunRemove(n1, sl) {\r\n        let s2 = this.getS(sl);\r\n        if (s2 == 0xf)\r\n            return true;\r\n        let s1 = this.getS(n1);\r\n        return s1 < s2;\r\n    },\r\n    /**# Remove Sun Light\r\n     * ---\r\n     * Removes the sun light from a light encoded value.\r\n     * @param sl - source light value\r\n     */\r\n    removeSunLight(sl) {\r\n        return this.removeS(sl);\r\n    },\r\n    minusOneForAll(sl) {\r\n        let s = this.getS(sl) - this.SRS;\r\n        let r = this.getR(sl) - 1;\r\n        let g = this.getG(sl) - 1;\r\n        let b = this.getB(sl) - 1;\r\n        if (s < 0)\r\n            s = 0;\r\n        if (r < 0)\r\n            r = 0;\r\n        if (g < 0)\r\n            g = 0;\r\n        if (b < 0)\r\n            b = 0;\r\n        let nl = this.setS(s, 0);\r\n        nl = this.setR(r, nl);\r\n        nl = this.setG(g, nl);\r\n        nl = this.setB(b, nl);\r\n        return nl;\r\n    },\r\n};\r\n","export const Register = {\r\n    stringMaps: {\r\n        segments: new Map(),\r\n        syncStringMap(data) {\r\n            const [segment, id, value] = data;\r\n            let segmentMap = this.segments.get(segment);\r\n            if (!segmentMap) {\r\n                segmentMap = new Map();\r\n                this.segments.set(segment, segmentMap);\r\n            }\r\n            segmentMap.set(id, value);\r\n            return;\r\n        },\r\n        getStringMapValue(segment, id, index) {\r\n            const segmentMap = this.segments.get(segment);\r\n            if (!segmentMap)\r\n                return \"\";\r\n            const map = segmentMap.get(id);\r\n            if (!map) {\r\n                // throw new Error(`${id} does not exists`);\r\n                return \"\";\r\n            }\r\n            return map[index];\r\n        },\r\n    },\r\n};\r\nRegister.stringMaps.segments.set(\"voxel\", new Map());\r\n","export const VoxelPaletteReader = {\r\n    _palette: [\"dve_air\", \"dve_barrier\"],\r\n    _map: new Map(),\r\n    setVoxelPalette(voxelPalette, voxelPaletteMap) {\r\n        this._palette = voxelPalette;\r\n        this._map = new Map(Object.entries(voxelPaletteMap));\r\n    },\r\n    id: {\r\n        stringFromNumber(id) {\r\n            return VoxelPaletteReader._palette[id];\r\n        },\r\n        numberFromString(id) {\r\n            return VoxelPaletteReader._map.get(id);\r\n        },\r\n        getPaletteId(voxelId, voxelState) {\r\n            const numericID = VoxelPaletteReader._map.get(voxelId);\r\n            if (numericID == undefined)\r\n                return -1;\r\n            const stateId = voxelState + numericID;\r\n            if (VoxelPaletteReader._palette[stateId] != voxelId) {\r\n                throw new Error(`${voxelState} is not a valid state for voxel with id : ${voxelId}`);\r\n            }\r\n            if (stateId) {\r\n                return stateId;\r\n            }\r\n            return -1;\r\n        },\r\n        baseNumeric(id) {\r\n            if (id < 2)\r\n                return id;\r\n            const vid = this.numberFromString(this.stringFromNumber(id));\r\n            if (!vid)\r\n                return -1;\r\n            return vid;\r\n        },\r\n    },\r\n};\r\n","const voxelStateMasks = {\r\n    level: 0b00_1111,\r\n    levelState: 0b11_0000,\r\n    shapeState: 0b1111_1111_11_00_0000,\r\n};\r\n/**# Voxel Byte\r\n * ---\r\n * Used to decode voxel data.\r\n */\r\nexport const VoxelReader = {\r\n    getLevel(stateData) {\r\n        return stateData & voxelStateMasks.level;\r\n    },\r\n    setLevel(stateData, level) {\r\n        return (stateData & ~voxelStateMasks.level) | level;\r\n    },\r\n    getLevelState(stateData) {\r\n        return (stateData & voxelStateMasks.levelState) >> 4;\r\n    },\r\n    setLevelState(stateData, levelState) {\r\n        return (stateData & ~voxelStateMasks.levelState) | (levelState << 4);\r\n    },\r\n    getShapeState(voxelData) {\r\n        return (voxelData & voxelStateMasks.shapeState) >> 6;\r\n    },\r\n    setShapeState(voxelData, shapeState) {\r\n        return (voxelData & ~voxelStateMasks.shapeState) | (shapeState << 6);\r\n    },\r\n};\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nclass VDTags extends RemoteTagManager {\r\n    id;\r\n    voxelIndex = new Uint16Array();\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    sync(voxelMap) {\r\n        this.voxelIndex = voxelMap;\r\n    }\r\n    setVoxel(id) {\r\n        const index = this.voxelIndex[id];\r\n        this.setTagIndex(index);\r\n    }\r\n}\r\nexport const VoxelTags = new VDTags(\"voxel-data\");\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const ChunkTags = new RemoteTagManager(\"chunk-tags\");\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const ColumnTags = new RemoteTagManager(\"column-tags\");\r\n","import { DataHooks } from \"../../DataHooks.js\";\r\nimport { WorldRegister } from \"../WorldRegister.js\";\r\nexport const DimensionsRegister = {\r\n    _count: 1,\r\n    dimensionRecord: {\r\n        main: 0,\r\n    },\r\n    dimensionMap: {\r\n        0: \"main\",\r\n    },\r\n    __defaultDimensionOptions: {\r\n        liquidFlowSpeed: 0.1,\r\n        magmaFlowSpeed: 0.1,\r\n        sunLight: true,\r\n    },\r\n    _dimensions: {},\r\n    registerDimension(id, option) {\r\n        if (!option) {\r\n            option = this.__defaultDimensionOptions;\r\n        }\r\n        const dimensionData = {\r\n            id: id,\r\n            options: option,\r\n        };\r\n        this._dimensions[id] = dimensionData;\r\n        this.dimensionRecord[id] = this._count;\r\n        this.dimensionMap[this._count] = id;\r\n        DataHooks.dimension.onRegisterDimension.run(dimensionData);\r\n        WorldRegister.dimensions.add(id);\r\n    },\r\n    getDimension(id) {\r\n        id = this.getDimensionStringId(id);\r\n        return this._dimensions[id];\r\n    },\r\n    getDimensionStringId(id) {\r\n        if (typeof id == \"number\") {\r\n            return this.dimensionMap[id];\r\n        }\r\n        return id;\r\n    },\r\n    getDimensionNumericId(id) {\r\n        if (typeof id == \"string\") {\r\n            return this.dimensionRecord[id];\r\n        }\r\n        return id;\r\n    },\r\n};\r\n","import { WorldSpaces } from \"../WorldSpaces.js\";\r\nimport { RegionHeaderTags } from \"./RegionTags.js\";\r\nexport const RegionHeaderRegister = {\r\n    _headers: new Map(),\r\n    remove(location) {\r\n        const [dimensionId, x, y, z] = location;\r\n        const dimension = this._headers.get(dimensionId);\r\n        if (!dimension)\r\n            return false;\r\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\r\n        return dimension.delete(regionKey);\r\n    },\r\n    add(location, buffer) {\r\n        const [dimensionId, x, y, z] = location;\r\n        let dimension = this._headers.get(dimensionId);\r\n        if (!dimension) {\r\n            dimension = new Map();\r\n            this._headers.set(dimensionId, dimension);\r\n        }\r\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\r\n        dimension.set(regionKey, {\r\n            buffer: buffer,\r\n            data: new DataView(buffer),\r\n        });\r\n    },\r\n    get(location) {\r\n        const [dimensionId, x, y, z] = location;\r\n        let dimension = this._headers.get(dimensionId);\r\n        if (!dimension)\r\n            return false;\r\n        return dimension.get(WorldSpaces.region.getKeyXYZ(x, y, z));\r\n    },\r\n    /**# isStored\r\n     * @param location\r\n     * @returns\r\n     *\r\n     * Returns 1 if stored\r\n     *\r\n     * Returns 0 if not stored\r\n     *\r\n     * Returns -1 if region header is not loaded\r\n     *\r\n     */\r\n    isStored(location) {\r\n        const header = this.get(location);\r\n        if (!header)\r\n            return -1;\r\n        RegionHeaderTags.setBuffer(header.data);\r\n        const columnIndex = WorldSpaces.column.getIndexXYZ(location[1], location[2], location[3]);\r\n        return RegionHeaderTags.getArrayTagValue(\"#dved-column-save-timestamp\", columnIndex) != 0\r\n            ? 1\r\n            : 0;\r\n    },\r\n};\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const RegionTags = new RemoteTagManager(\"region-tags\");\r\nexport const RegionHeaderTags = new RemoteTagManager(\"region-header-tags\");\r\n","import { WorldRegister } from \"./WorldRegister.js\";\r\nimport { DataHooks } from \"../DataHooks.js\";\r\nimport { VoxelPaletteReader } from \"../Voxel/VoxelPalette.js\";\r\nimport { DataTool } from \"../../Tools/Data/DataTool.js\";\r\nconst WP = {\r\n    _currentionDimension: \"main\",\r\n    paint: {\r\n        _dt: new DataTool(),\r\n        voxel(location, data, update = true) {\r\n            if (!location[0]) {\r\n                location[0] = WP._currentionDimension;\r\n            }\r\n            let chunk = WorldRegister.chunk.get(location);\r\n            if (!chunk) {\r\n                let buffer = DataHooks.chunk.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                chunk = WorldRegister.chunk.add(location, buffer);\r\n            }\r\n            this.__paint(location, data, update);\r\n        },\r\n        __paint(location, data, update = true) {\r\n            this._dt.setLocation(location);\r\n            if (!this._dt.setLocation(location).loadIn())\r\n                return;\r\n            const id = VoxelPaletteReader.id.getPaletteId(data.id, data.state ? data.state : 0);\r\n            if (id < 0)\r\n                return false;\r\n            this._dt.setId(id);\r\n            this._dt.setShapeState(data.shapeState ? data.shapeState : 0);\r\n            const substance = this._dt.getSubstance();\r\n            if (substance == \"#dve_liquid\" || substance == \"#dve_magma\") {\r\n                this._dt.setLevel(15);\r\n            }\r\n            if (data.secondaryVoxelId && data.secondaryVoxelId != \"dve_air\") {\r\n                const vid = VoxelPaletteReader.id.getPaletteId(data.secondaryVoxelId, data.secondaryState ? data.secondaryState : 0);\r\n                if (vid > 0) {\r\n                    this._dt.setSecondary(true);\r\n                    this._dt.setId(vid);\r\n                    this._dt.setSecondary(false);\r\n                }\r\n            }\r\n            if (this._dt.isLightSource() && this._dt.getLightSourceValue()) {\r\n                this._dt.setLight(this._dt.getLightSourceValue());\r\n                if (update) {\r\n                    DataHooks.paint.onAddToRGBUpdate.run(location);\r\n                }\r\n            }\r\n            if (this._dt.isRich()) {\r\n                DataHooks.paint.onRichVoxelPaint.run([this._dt.getStringId(), location]);\r\n            }\r\n            this._dt.commit(1);\r\n        },\r\n        erase(location) {\r\n            this._dt.setLocation(location);\r\n            if (!this._dt.loadIn())\r\n                return;\r\n            if (!this._dt.isRenderable())\r\n                return;\r\n            this._dt\r\n                .setLight(0)\r\n                .setLevel(0)\r\n                .setLevelState(0)\r\n                .setShapeState(0)\r\n                .setAir()\r\n                .commit(2);\r\n        },\r\n    },\r\n};\r\nexport const WorldPainter = WP;\r\n","import { DataHooks } from \"../../Data/DataHooks.js\";\r\nimport { WorldBounds } from \"./WorldBounds.js\";\r\nimport { $2dMooreNeighborhood } from \"../Constants/Util/CardinalNeighbors.js\";\r\nimport { DimensionsRegister } from \"./Dimensions/DimensionsRegister.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\r\nimport { RegionDataTool } from \"../../Tools/Data/WorldData/RegionDataTool.js\";\r\nimport { WorldSpaces } from \"./WorldSpaces.js\";\r\nconst chunkTool = new ChunkDataTool();\r\nconst columnTool = new ColumnDataTool();\r\nconst regionTool = new RegionDataTool();\r\nexport const WorldRegister = {\r\n    _dimensions: new Map(),\r\n    _cacheOn: false,\r\n    _chunkCache: new Map(),\r\n    _columnCache: new Map(),\r\n    cache: {\r\n        enable() {\r\n            WorldRegister._cacheOn = true;\r\n            WorldRegister._chunkCache.clear();\r\n            WorldRegister._columnCache.clear();\r\n        },\r\n        disable() {\r\n            WorldRegister._cacheOn = false;\r\n            WorldRegister._chunkCache.clear();\r\n            WorldRegister._columnCache.clear();\r\n        },\r\n        _addChunk(key, data) {\r\n            WorldRegister._chunkCache.set(key, data);\r\n        },\r\n        _addColumn(key, data) {\r\n            WorldRegister._columnCache.set(key, data);\r\n        },\r\n        _getChunk(key) {\r\n            return WorldRegister._chunkCache.get(key);\r\n        },\r\n        _getColumn(key) {\r\n            return WorldRegister._columnCache.get(key);\r\n        },\r\n    },\r\n    dimensions: {\r\n        add(id) {\r\n            const dimesnion = new Map();\r\n            id = DimensionsRegister.getDimensionStringId(id);\r\n            WorldRegister._dimensions.set(id, dimesnion);\r\n            return dimesnion;\r\n        },\r\n        get(id) {\r\n            id = DimensionsRegister.getDimensionStringId(id);\r\n            return WorldRegister._dimensions.get(id);\r\n        },\r\n    },\r\n    region: {\r\n        add(location, sab) {\r\n            let dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension) {\r\n                dimension = WorldRegister.dimensions.add(location[0]);\r\n            }\r\n            const region = this._getRegionData(sab);\r\n            const regionPOS = WorldSpaces.region.getPositionLocation(location);\r\n            regionTool.setRegion(region);\r\n            regionTool.setPositionData(regionPOS.x, regionPOS.y, regionPOS.z);\r\n            regionTool.setDimensionId(location[0]);\r\n            dimension.set(WorldSpaces.region.getKey(), region);\r\n            return region;\r\n        },\r\n        _getRegionData(sab) {\r\n            return {\r\n                columns: new Map(),\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        get(location) {\r\n            const dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const region = dimension.get(WorldSpaces.region.getKeyLocation(location));\r\n            if (!region)\r\n                return false;\r\n            return region;\r\n        },\r\n        remove(location) {\r\n            const dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const key = WorldSpaces.region.getKeyLocation(location);\r\n            const region = dimension.get(key);\r\n            if (!region)\r\n                return false;\r\n            dimension.delete(key);\r\n            return true;\r\n        },\r\n    },\r\n    column: {\r\n        add(location, sab) {\r\n            let region = WorldRegister.region.get(location);\r\n            if (!region) {\r\n                let buffer = DataHooks.region.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                region = WorldRegister.region.add(location, buffer);\r\n                DataHooks.region.onNew.run(location);\r\n            }\r\n            const column = this._getColumnData(sab);\r\n            const columnPOS = WorldSpaces.column.getPositionLocation(location);\r\n            columnTool.setColumn(column);\r\n            columnTool.setPositionData(columnPOS.x, columnPOS.y, columnPOS.z);\r\n            columnTool.setDimensionId(location[0]);\r\n            region.columns.set(WorldSpaces.column.getIndex(), column);\r\n            return column;\r\n        },\r\n        _getColumnData(sab) {\r\n            return {\r\n                chunks: new Map(),\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        get(location) {\r\n            const columnKey = WorldSpaces.column.getKeyLocation(location);\r\n            let addColumn = false;\r\n            if (WorldRegister._cacheOn) {\r\n                const column = WorldRegister.cache._getColumn(columnKey);\r\n                if (column)\r\n                    return column;\r\n                addColumn = true;\r\n            }\r\n            const region = WorldRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const column = region.columns.get(WorldSpaces.column.getIndexLocation(location));\r\n            if (!column)\r\n                return false;\r\n            if (addColumn) {\r\n                WorldRegister.cache._addColumn(columnKey, column);\r\n            }\r\n            return column;\r\n        },\r\n        remove(location) {\r\n            const region = WorldRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const index = WorldSpaces.column.getIndexLocation(location);\r\n            const column = region.columns.get(index);\r\n            if (!column)\r\n                return false;\r\n            region.columns.delete(index);\r\n            return true;\r\n        },\r\n        fill(location) {\r\n            for (let cy = WorldBounds.bounds.MinY; cy < WorldBounds.bounds.MaxY; cy += WorldSpaces.chunk._bounds.y) {\r\n                location[2] = cy;\r\n                if (!WorldRegister.chunk.get(location)) {\r\n                    const chunk = DataHooks.chunk.onGetSync.run(location);\r\n                    if (!chunk)\r\n                        continue;\r\n                    WorldRegister.chunk.add(location, chunk);\r\n                }\r\n            }\r\n        },\r\n        height: {\r\n            getRelative(location) {\r\n                location = [...location];\r\n                const chunkWidth = WorldSpaces.chunk._bounds.x;\r\n                const chunkDepth = WorldSpaces.chunk._bounds.z;\r\n                let maxHeight = -Infinity;\r\n                const [dimension, x, y, z] = location;\r\n                for (const check of $2dMooreNeighborhood) {\r\n                    location[1] = check[0] * chunkWidth + x;\r\n                    location[3] = check[1] * chunkDepth + z;\r\n                    const height = this.getAbsolute(location);\r\n                    if (height > maxHeight) {\r\n                        maxHeight = height;\r\n                    }\r\n                }\r\n                return maxHeight;\r\n            },\r\n            getAbsolute(location) {\r\n                const column = WorldRegister.column.get(location);\r\n                if (!column)\r\n                    return WorldBounds.bounds.MinY;\r\n                if (column.chunks.size == 0)\r\n                    return WorldBounds.bounds.MinY;\r\n                let maxHeight = WorldBounds.bounds.MinY;\r\n                for (const [key, chunk] of column.chunks) {\r\n                    if (!chunk)\r\n                        continue;\r\n                    chunkTool.setChunk(chunk);\r\n                    const chunkPOS = chunkTool.getPositionData();\r\n                    let chunkMax = chunkTool.getTagValue(\"#dve_max_height\");\r\n                    if (chunkMax == 0)\r\n                        continue;\r\n                    chunkMax += chunkPOS.y;\r\n                    if (maxHeight < chunkMax) {\r\n                        maxHeight = chunkMax;\r\n                    }\r\n                }\r\n                return maxHeight + 1;\r\n            },\r\n        },\r\n    },\r\n    chunk: {\r\n        add(location, sab) {\r\n            let column = WorldRegister.column.get(location);\r\n            if (!column) {\r\n                let buffer = DataHooks.column.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                column = WorldRegister.column.add(location, buffer);\r\n                DataHooks.column.onNew.run(location);\r\n            }\r\n            if (!column)\r\n                return;\r\n            const chunk = this._getChunkData(sab);\r\n            chunkTool.setChunk(chunk);\r\n            const chunkPOS = WorldSpaces.chunk.getPositionLocation(location);\r\n            chunkTool.setPositionData(chunkPOS.x, chunkPOS.y, chunkPOS.z);\r\n            chunkTool.setDimensionId(location[0]);\r\n            column.chunks.set(WorldSpaces.chunk.getIndex(), chunk);\r\n            DataHooks.chunk.onNew.run(location);\r\n            return chunk;\r\n        },\r\n        _getChunkData(sab) {\r\n            return {\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        addFromServer(chunkBuffer) {\r\n            const sab = new SharedArrayBuffer(chunkBuffer.byteLength);\r\n            const temp = new Uint8Array(chunkBuffer);\r\n            const temp2 = new Uint8Array(sab);\r\n            temp2.set(temp, 0);\r\n            const chunk = this._getChunkData(sab);\r\n            chunkTool.setChunk(chunk);\r\n            const location = chunkTool.getLocationData();\r\n            let column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return;\r\n            column.chunks.set(WorldSpaces.chunk.getIndexLocation(location), chunk);\r\n            DataHooks.chunk.onNew.run(location);\r\n            return chunk;\r\n        },\r\n        get(location) {\r\n            const chunkKey = WorldSpaces.chunk.getKeyLocation(location);\r\n            let addChunk = false;\r\n            if (WorldRegister._cacheOn) {\r\n                const chunk = WorldRegister.cache._getChunk(chunkKey);\r\n                if (chunk)\r\n                    return chunk;\r\n                addChunk = true;\r\n            }\r\n            const column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const chunk = column.chunks.get(WorldSpaces.chunk.getIndex());\r\n            if (!chunk)\r\n                return;\r\n            if (addChunk) {\r\n                WorldRegister.cache._addChunk(chunkKey, chunk);\r\n            }\r\n            return chunk;\r\n        },\r\n        remove(location) {\r\n            const column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const index = WorldSpaces.chunk.getIndexLocation(location);\r\n            const chunk = column.chunks.get(index);\r\n            if (!chunk)\r\n                return false;\r\n            column.chunks.delete(index);\r\n            return true;\r\n        },\r\n    },\r\n};\r\n","import { Util } from \"../../Global/Util.helper.js\";\r\nimport { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\r\nimport { LocationBoundTool } from \"./LocationBoundTool.js\";\r\nimport { WorldDataTagIDs } from \"../../Data/Constants/Tags/WorldDataTagIds.js\";\r\nexport class DataToolBase extends LocationBoundTool {\r\n    tags;\r\n    _c;\r\n    constructor() {\r\n        super();\r\n    }\r\n    getTagValue(id) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.getTag(id);\r\n    }\r\n    setTagValue(id, value) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.setTag(id, value);\r\n    }\r\n    getArrayTagValue(id, index) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.getArrayTagValue(id, index);\r\n    }\r\n    setArrayTagValue(id, index, value) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.setArrayTagValue(id, index, value);\r\n    }\r\n    setBuffer(buffer) {\r\n        this._c = buffer;\r\n        this.tags.setBuffer(this._c);\r\n    }\r\n    getBuffer() {\r\n        if (this._c instanceof DataView)\r\n            return this._c.buffer;\r\n        return this._c;\r\n    }\r\n    getAsArrayBuffer() {\r\n        return Util.converSABToBuffer(this.getBuffer());\r\n    }\r\n    getBufferSize() {\r\n        return this.tags.tagSize;\r\n    }\r\n    loadInAt(x, y, z) {\r\n        this.setXYZ(x, y, z);\r\n        return this.loadIn();\r\n    }\r\n    loadInAtLocation(location) {\r\n        this.setLocation(location);\r\n        return this.loadIn();\r\n    }\r\n}\r\nexport class EncodedPositionDataTool extends DataToolBase {\r\n    position = { x: 0, y: 0, z: 0 };\r\n    constructor() {\r\n        super();\r\n    }\r\n    getPositionData() {\r\n        this.position.x = this.getTagValue(WorldDataTagIDs.positionX);\r\n        this.position.y = this.getTagValue(WorldDataTagIDs.positionY);\r\n        this.position.z = this.getTagValue(WorldDataTagIDs.positionZ);\r\n        return this.position;\r\n    }\r\n    setPositionData(x, y, z) {\r\n        this.setTagValue(WorldDataTagIDs.positionX, x);\r\n        this.setTagValue(WorldDataTagIDs.positionY, y);\r\n        this.setTagValue(WorldDataTagIDs.positionZ, z);\r\n        return this.position;\r\n    }\r\n    setDimensionId(dimensionId) {\r\n        this.setTagValue(WorldDataTagIDs.dimensionId, DimensionsRegister.getDimensionNumericId(dimensionId));\r\n    }\r\n    getDimensionId() {\r\n        return DimensionsRegister.getDimensionStringId(this.getTagValue(WorldDataTagIDs.dimensionId));\r\n    }\r\n    getLocationData() {\r\n        const pos = this.getPositionData();\r\n        return [this.getDimensionId(), pos.x, pos.y, pos.z];\r\n    }\r\n}\r\n","export class LocationBoundTool {\r\n    location = [\"main\", 0, 0, 0];\r\n    get dimension() {\r\n        return this.location[0];\r\n    }\r\n    set dimension(dimension) {\r\n        this.location[0] = dimension;\r\n    }\r\n    get x() {\r\n        return this.location[1];\r\n    }\r\n    set x(value) {\r\n        this.location[1] = value;\r\n    }\r\n    get y() {\r\n        return this.location[2];\r\n    }\r\n    set y(value) {\r\n        this.location[2] = value;\r\n    }\r\n    get z() {\r\n        return this.location[3];\r\n    }\r\n    set z(value) {\r\n        this.location[3] = value;\r\n    }\r\n    setDimension(dimensionId) {\r\n        this.location[0] = dimensionId;\r\n        return this;\r\n    }\r\n    getLocation() {\r\n        return this.location;\r\n    }\r\n    setXYZ(x, y, z) {\r\n        this.location[1] = x;\r\n        this.location[2] = y;\r\n        this.location[3] = z;\r\n        return this;\r\n    }\r\n    setXZ(x, z) {\r\n        this.setXYZ(x, this.location[2], z);\r\n        return this;\r\n    }\r\n    setLocation(location) {\r\n        this.location[0] = location[0];\r\n        this.location[1] = location[1];\r\n        this.location[2] = location[2];\r\n        this.location[3] = location[3];\r\n        return this;\r\n    }\r\n}\r\n","import { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\r\nimport { VoxelReader } from \"../../Data/Voxel/VoxelReader.js\";\r\nimport { VoxelTags } from \"../../Data/Voxel/VoxelTags.js\";\r\nimport { VoxelPaletteReader } from \"../../Data/Voxel/VoxelPalette.js\";\r\nimport { ChunkDataTool } from \"./WorldData/ChunkDataTool.js\";\r\nimport { HeightMapTool } from \"./WorldData/HeightMapTool.js\";\r\nimport { DataToolBase } from \"../Classes/DataToolBase.js\";\r\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\r\nimport { ColumnDataTool } from \"./WorldData/ColumnDataTool.js\";\r\nimport { LightData } from \"../../Data/Light/LightByte.js\";\r\nimport { VoxelTagIDs } from \"../../Data/Constants/Tags/VoxelTagIds.js\";\r\nimport { Register } from \"../../Data/Register/Register.js\";\r\nexport class DataTool extends DataToolBase {\r\n    static _dtutil = new DataTool();\r\n    _chunkTool = new ChunkDataTool();\r\n    static _heightMapTool = new HeightMapTool();\r\n    static _columntool = new ColumnDataTool();\r\n    _locationKey = \"\";\r\n    _loadedIn = false;\r\n    _mode = \"World\";\r\n    data = {\r\n        raw: [0, 0, 0, 0],\r\n        id: 0,\r\n        baseId: 0,\r\n        secondaryId: 0,\r\n        secondaryBaseId: 0,\r\n    };\r\n    __secondary = false;\r\n    tags = VoxelTags;\r\n    setDimension(dimensionId) {\r\n        this.location[0] = DimensionsRegister.getDimensionStringId(dimensionId);\r\n        return this;\r\n    }\r\n    setSecondary(enable) {\r\n        this.__secondary = enable;\r\n        if (enable) {\r\n            VoxelTags.setVoxel(this.data.secondaryBaseId);\r\n        }\r\n        else {\r\n            VoxelTags.setVoxel(this.data.baseId);\r\n        }\r\n        return this;\r\n    }\r\n    _getBaseId(id) {\r\n        return VoxelPaletteReader.id.baseNumeric(id);\r\n    }\r\n    loadInRaw(rawData) {\r\n        this.data.raw = rawData;\r\n        this.__process();\r\n    }\r\n    __process() {\r\n        this.data.id = this.data.raw[0];\r\n        this.data.secondaryId = this.data.raw[3];\r\n        this.data.baseId = this._getBaseId(this.data.id);\r\n        if (this.data.secondaryId > 1) {\r\n            this.data.secondaryBaseId = this._getBaseId(this.data.secondaryId);\r\n        }\r\n        else {\r\n            this.data.secondaryBaseId = 0;\r\n        }\r\n        VoxelTags.setVoxel(this.data.baseId);\r\n    }\r\n    loadIn() {\r\n        this._c = this.tags.data;\r\n        if (this._mode == \"World\") {\r\n            if (!this._chunkTool.setLocation(this.location).loadIn())\r\n                return false;\r\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\r\n            this.data.raw[0] = this._chunkTool.segments.id.get(index);\r\n            this.data.raw[1] = this._chunkTool.segments.light.get(index);\r\n            this.data.raw[2] = this._chunkTool.segments.state.get(index);\r\n            this.data.raw[3] = this._chunkTool.segments.secondaryId.get(index);\r\n            this.__process();\r\n            this._loadedIn = true;\r\n            return true;\r\n        }\r\n        if (this._mode == \"Entity\") {\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n    commit(heightMapUpdate = 0) {\r\n        if (!this._loadedIn)\r\n            return false;\r\n        if (this._mode == \"World\") {\r\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\r\n            this._chunkTool.segments.id.set(index, this.data.raw[0]);\r\n            this._chunkTool.segments.light.set(index, this.data.raw[1]);\r\n            this._chunkTool.segments.state.set(index, this.data.raw[2]);\r\n            this._chunkTool.segments.secondaryId.set(index, this.data.raw[3]);\r\n            if (heightMapUpdate) {\r\n                DataTool._heightMapTool.chunk._c = this._chunkTool._c;\r\n                const substance = this.getTemplateSubstance();\r\n                //on add\r\n                if (heightMapUpdate == 1) {\r\n                    DataTool._heightMapTool.chunk.update(\"add\", substance, this.location);\r\n                }\r\n                //on remove\r\n                if (heightMapUpdate == 2) {\r\n                    DataTool._heightMapTool.chunk.update(\"remove\", substance, this.location);\r\n                }\r\n            }\r\n            if (DataTool._columntool.setLocation(this.location).loadIn()) {\r\n                DataTool._columntool.markAsNotStored();\r\n            }\r\n            this._loadedIn = false;\r\n            return true;\r\n        }\r\n        if (this._mode == \"Entity\") {\r\n        }\r\n        return false;\r\n    }\r\n    hasRGBLight() {\r\n        const light = this.getLight();\r\n        if (light <= 0)\r\n            false;\r\n        return LightData.hasRGBLight(light);\r\n    }\r\n    hasSunLight() {\r\n        const light = this.getLight();\r\n        if (light <= 0)\r\n            false;\r\n        return LightData.hasSunLight(light);\r\n    }\r\n    getLight() {\r\n        const vID = this.getId(true);\r\n        VoxelTags.setVoxel(vID);\r\n        if (vID == 0)\r\n            return this.data.raw[1];\r\n        if (vID < 2)\r\n            return -1;\r\n        const lightValue = this.getTagValue(VoxelTagIDs.lightValue);\r\n        if (this.isOpaque()) {\r\n            if (this.getTagValue(VoxelTagIDs.isLightSource) && lightValue) {\r\n                return lightValue;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        if (this.getTagValue(\"#dve_is_light_source\") && lightValue) {\r\n            return LightData.mixLight(this.data.raw[1], lightValue);\r\n        }\r\n        return this.data.raw[1];\r\n    }\r\n    setLight(light) {\r\n        this.data.raw[1] = light;\r\n        return this;\r\n    }\r\n    isOpaque() {\r\n        const substance = this.getSubstance();\r\n        if (substance == \"#dve_solid\")\r\n            return true;\r\n    }\r\n    getLevel() {\r\n        return VoxelReader.getLevel(this.data.raw[2]);\r\n    }\r\n    setLevel(level) {\r\n        this.data.raw[2] = VoxelReader.setLevel(this.data.raw[2], level);\r\n        return this;\r\n    }\r\n    getLevelState() {\r\n        return VoxelReader.getLevelState(this.data.raw[2]);\r\n    }\r\n    setLevelState(state) {\r\n        this.data.raw[2] = VoxelReader.setLevelState(this.data.raw[2], state);\r\n        return this;\r\n    }\r\n    getShapeState() {\r\n        return VoxelReader.getShapeState(this.data.raw[2]);\r\n    }\r\n    setShapeState(state) {\r\n        this.data.raw[2] = VoxelReader.setShapeState(this.data.raw[2], state);\r\n        return this;\r\n    }\r\n    hasSecondaryVoxel() {\r\n        return this.data.secondaryBaseId > 1;\r\n    }\r\n    //voxel data\r\n    getShapeId() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.shapeID, VoxelTags.getTag(VoxelTagIDs.shapeID));\r\n    }\r\n    isLightSource() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return false;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource) == 1;\r\n    }\r\n    getLightSourceValue() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.lightValue);\r\n    }\r\n    getSubstance() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"#dve_transparent\";\r\n        VoxelTags.setVoxel(vID);\r\n        const s = (Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.substance, VoxelTags.getTag(VoxelTagIDs.substance)));\r\n        return s;\r\n    }\r\n    getMaterial() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"none\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.material, VoxelTags.getTag(VoxelTagIDs.material));\r\n    }\r\n    getHardness() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.hardness);\r\n    }\r\n    getCollider() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"none\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.colliderID, VoxelTags.getTag(VoxelTagIDs.colliderID));\r\n    }\r\n    checkCollisions() {\r\n        const vID = this.getId(true);\r\n        if (vID == 0)\r\n            return false;\r\n        if (vID == 1)\r\n            return true;\r\n        VoxelTags.setVoxel(vID);\r\n        return this.getTagValue(VoxelTagIDs.checkCollisions) == 1;\r\n    }\r\n    getTemplateSubstance() {\r\n        let substance = this.getSubstance();\r\n        if (substance == \"#dve_transparent\") {\r\n            substance = \"#dve_solid\";\r\n        }\r\n        return substance;\r\n    }\r\n    getState() {\r\n        if (this.__secondary) {\r\n            return this.data.secondaryId - this.data.secondaryBaseId;\r\n        }\r\n        return this.data.id - this.data.baseId;\r\n    }\r\n    isRich() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource);\r\n    }\r\n    //util\r\n    setAir() {\r\n        this.data.raw[0] = 0;\r\n        this.__process();\r\n        return this;\r\n    }\r\n    isAir() {\r\n        return 0 == this.data.raw[0];\r\n    }\r\n    setBarrier() {\r\n        this.data.raw[0] = 1;\r\n        this.__process();\r\n        return this;\r\n    }\r\n    isBarrier() {\r\n        return 1 == this.data.raw[0];\r\n    }\r\n    //voxel id\r\n    getId(base = false) {\r\n        if (this.__secondary) {\r\n            if (!base)\r\n                return this.data.secondaryId;\r\n            return this.data.secondaryBaseId;\r\n        }\r\n        if (!base)\r\n            return this.data.id;\r\n        return this.data.baseId;\r\n    }\r\n    setId(id) {\r\n        if (this.__secondary) {\r\n            this.data.raw[3] = id;\r\n            this.data.secondaryId = id;\r\n            this.data.secondaryBaseId = this._getBaseId(id);\r\n            return this;\r\n        }\r\n        this.data.raw[0] = id;\r\n        this.data.id = id;\r\n        this.data.baseId = this._getBaseId(id);\r\n        return this;\r\n    }\r\n    getStringId() {\r\n        if (this.__secondary) {\r\n            return VoxelPaletteReader.id.stringFromNumber(this.data.secondaryBaseId);\r\n        }\r\n        return VoxelPaletteReader.id.stringFromNumber(this.data.baseId);\r\n    }\r\n    //util\r\n    isRenderable() {\r\n        if (this.data.id < 2 && this.data.secondaryId < 2)\r\n            return false;\r\n        return true;\r\n    }\r\n    isSameVoxel(cx, cy, cz) {\r\n        DataTool._dtutil.loadInAt(cx, cy, cz);\r\n        if (this.__secondary) {\r\n            return this.data.secondaryBaseId == DataTool._dtutil.data.secondaryBaseId;\r\n        }\r\n        return this.data.baseId == DataTool._dtutil.data.baseId;\r\n    }\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { ChunkTagIDs } from \"../../../Data/Constants/Tags/ChunkTagIds.js\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nexport class ChunkDataTool extends EncodedPositionDataTool {\r\n    tags = ChunkTags;\r\n    constructor() {\r\n        super();\r\n        this.segments.id._s = this;\r\n        this.segments.light._s = this;\r\n        this.segments.state._s = this;\r\n        this.segments.secondaryId._s = this;\r\n    }\r\n    loadIn() {\r\n        WorldSpaces.chunk.updateLoaction(this.location);\r\n        const chunk = WorldRegister.chunk.get(this.location);\r\n        if (!chunk)\r\n            return false;\r\n        this.tags.setBuffer(chunk.data);\r\n        this._c = chunk.data;\r\n        return true;\r\n    }\r\n    setChunk(chunk) {\r\n        this.tags.setBuffer(chunk.data);\r\n        this._c = chunk.data;\r\n        return this;\r\n    }\r\n    segments = {\r\n        id: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelIDSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelIDSegment, index, value);\r\n            },\r\n        },\r\n        light: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelLightSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelLightSegment, index, value);\r\n            },\r\n        },\r\n        state: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelStateSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelStateSegment, index, value);\r\n            },\r\n        },\r\n        secondaryId: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index, value);\r\n            },\r\n        },\r\n    };\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { ColumnTags } from \"../../../Data/World/Column/ColumnTags.js\";\r\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\r\nexport class ColumnDataTool extends EncodedPositionDataTool {\r\n    tags = ColumnTags;\r\n    _column = {};\r\n    loadIn() {\r\n        const column = WorldRegister.column.get(this.location);\r\n        if (!column)\r\n            return false;\r\n        this.tags.setBuffer(column.data);\r\n        this._c = column.data;\r\n        this._column = column;\r\n        return true;\r\n    }\r\n    setColumn(column) {\r\n        this.tags.setBuffer(column.data);\r\n        this._c = column.data;\r\n        this._column = column;\r\n        return this;\r\n    }\r\n    getColumn() {\r\n        return this._column;\r\n    }\r\n    getNumChunks() {\r\n        return this._column.chunks.size;\r\n    }\r\n    getBufferSizeForWholeColumn() {\r\n        return ColumnTags.tagSize + ChunkTags.tagSize * this.getNumChunks();\r\n    }\r\n    isStored() {\r\n        return this.getTagValue(\"#dve_is_stored\") == 1;\r\n    }\r\n    markAsNotStored() {\r\n        this.setTagValue(\"#dve_is_stored\", 0);\r\n        return this;\r\n    }\r\n    markAsStored() {\r\n        this.setTagValue(\"#dve_is_stored\", 1);\r\n        return this;\r\n    }\r\n    isPersistent() {\r\n        return this.getTagValue(\"#dve_persistent\") == 1;\r\n    }\r\n    setPersistence(value) {\r\n        this.setTagValue(\"#dve_persistent\", value ? 1 : 0);\r\n    }\r\n    isDirty() {\r\n        return this.getTagValue(\"#dve_is_dirty\") == 1;\r\n    }\r\n    setDirty(value) {\r\n        this.setTagValue(\"#dve_is_dirty\", value ? 1 : 0);\r\n    }\r\n    getLastSaveTimestamp() {\r\n        return this.getTagValue(\"#dve_last_save_timestamp\");\r\n    }\r\n    setLastSaveTimestamp() {\r\n        return this.setTagValue(\"#dve_last_save_timestamp\", Date.now());\r\n    }\r\n    getLastAnalyzerUpdateTimestamp() {\r\n        return this.getTagValue(\"#dve_last_analyzer_update_timestamp\");\r\n    }\r\n    setLastAnalyzerUpdateTimestamp() {\r\n        return this.setTagValue(\"#dve_last_analyzer_update_timestamp\", Date.now());\r\n    }\r\n}\r\n","//Data\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { ChunkDataTool } from \"./ChunkDataTool.js\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nexport class HeightMapTool {\r\n    static _chunkTool = new ChunkDataTool();\r\n    _data = {\r\n        dimension: \"main\",\r\n    };\r\n    constructor() {\r\n        this.chunk._s = this;\r\n        //  this.column._s = this;\r\n    }\r\n    setDimension(dimensionId) {\r\n        this._data.dimension = dimensionId;\r\n    }\r\n    chunk = {\r\n        _p: {\r\n            x: 0,\r\n            z: 0,\r\n        },\r\n        _c: new DataView(new ArrayBuffer(0)),\r\n        _s: {},\r\n        loadInAt(x, y, z) {\r\n            const chunk = WorldRegister.chunk.get([this._s._data.dimension, x, y, z]);\r\n            if (!chunk)\r\n                return false;\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        loadInAtLocation(location) {\r\n            const chunk = WorldRegister.chunk.get(location);\r\n            if (!chunk)\r\n                return false;\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        setChunk(chunk) {\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        setXZ(x, z) {\r\n            this._p.x = x;\r\n            this._p.z = z;\r\n            return this;\r\n        },\r\n        getMinMax() {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            return [\r\n                HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\"),\r\n                HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\"),\r\n            ];\r\n        },\r\n        getMin(substance = \"all\") {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            if (substance == \"all\") {\r\n                return HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\");\r\n            }\r\n            return 0;\r\n        },\r\n        getMax(substance = \"all\") {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            if (substance == \"all\") {\r\n                return HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\");\r\n            }\r\n            return 0;\r\n        },\r\n        update(mode, substance = \"all\", location) {\r\n            if (mode == \"add\") {\r\n                HeightMapTool._chunkTool._c = this._c;\r\n                const minY = HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\");\r\n                const maxY = HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\");\r\n                const voxelPOS = WorldSpaces.voxel.getPositionLocation(location);\r\n                if (minY > voxelPOS.y) {\r\n                    HeightMapTool._chunkTool.setTagValue(\"#dve_min_height\", voxelPOS.y);\r\n                }\r\n                if (maxY < voxelPOS.y) {\r\n                    HeightMapTool._chunkTool.setTagValue(\"#dve_max_height\", voxelPOS.y);\r\n                }\r\n            }\r\n        },\r\n    };\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { RegionTags } from \"../../../Data/World/Region/RegionTags.js\";\r\nexport class RegionDataTool extends EncodedPositionDataTool {\r\n    tags = RegionTags;\r\n    _region = {};\r\n    loadIn() {\r\n        const reigon = WorldRegister.region.get(this.location);\r\n        if (!reigon)\r\n            return false;\r\n        this.tags.setBuffer(reigon.data);\r\n        this._region = reigon;\r\n        this._c = reigon.data;\r\n        return true;\r\n    }\r\n    setRegion(region) {\r\n        this.tags.setBuffer(region.data);\r\n        this._region = region;\r\n        this._c = region.data;\r\n        return this;\r\n    }\r\n    getRegion() {\r\n        return this._region;\r\n    }\r\n    getRegionDataCount() {\r\n        const region = this._region;\r\n        let totalChunks = 0;\r\n        region.columns.forEach((column) => {\r\n            totalChunks += column.chunks.size;\r\n        });\r\n        return {\r\n            chunks: totalChunks,\r\n            columns: region.columns.size,\r\n        };\r\n    }\r\n}\r\n"],"names":[],"sourceRoot":""}