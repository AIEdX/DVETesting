{"version":3,"file":"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-75c735.DVE.js","mappings":";;;;;;;;;;;;;;AAA2D;AAC3D;AACA;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,mBAAmB,iEAAmB;AACtC;AACA,4BAA4B,sEAAwB;AACpD,mBAAmB,oEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,+DAA+D,iEAAmB;AAClF;AACA;AACA,4BAA4B,sEAAwB;AACpD,YAAY,oEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;ACxIyD;AACZ;AACtC;AACP;AACA,mBAAmB,sDAAU;AAC7B,KAAK;AACL;AACA,mBAAmB,kEAAgB;AACnC,KAAK;AACL;;;;;;;;;;;;;;;;ACT6D;AACtD,+BAA+B,sEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChB4E;AACf;AAC7D,qBAAqB,kEAAoB,WAAW,kEAAoB;AACxE;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO,yBAAyB,sEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,mGAAmG,kEAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uGAAuG,iEAAmB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,2EAA6B;AACtJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnLU;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9HsC;AACA;AACN;AACY;AACD;AACL;AACJ;;;;;;;;;;;;;;;ACN3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZmD;AACF;AAC1C;AACP;AACA,mBAAmB,4DAAS;AAC5B,KAAK;AACL;AACA,mBAAmB,0DAAQ;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;ACT2B;;;;;;;;;;;;;;;ACApB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBqC;AAC9B;AACP;AACA,6BAA6B,2DAAiB;AAC9C,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,0BAA0B,2DAAiB;AAC3C,0BAA0B,2DAAiB;AAC3C,KAAK;AACL,oBAAoB,2DAAiB;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;AC5B8E;AAC5B;AACD;AACI;AACE;AACE;AACF;AACG;AACA;AACL;AACyB;AACvE;AACP,gBAAgB,uFAAkB;AAClC,eAAe,0DAAS;AACxB,WAAW,gEAAY;AACvB,mBAAmB,kEAAa;AAChC,gBAAgB,mEAAU;AAC1B,iBAAiB,8DAAW;AAC5B,YAAY,8DAAW;AACvB,cAAc,2DAAQ;AACtB,eAAe,gEAAS;AACxB,gBAAgB,mEAAU;AAC1B,0BAA0B,wFAAoB;AAC9C;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACjXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC1BO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,2CAA2C,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5BsD;AACtD,qBAAqB,gEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;AChB+C;AAC/C,sBAAsB,gEAAgB;;;;;;;;;;;;;;;;ACDS;AAC/C,uBAAuB,gEAAgB;;;;;;;;;;;;;;;;;ACDC;AACK;AAC7C;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAA2C;AACnD,QAAQ,2EAA4B;AACpC,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC9CgD;AACG;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA4B;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAA0B;AAClC,4BAA4B,2EAA8B;AAC1D,eAAe,6EAAiC;AAChD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACrDsD;AAC/C,uBAAuB,gEAAgB;AACvC,6BAA6B,gEAAgB;;;;;;;;;;;;;;;;;;;ACFD;AACP;AACkB;AACN;AACxD;AACA;AACA;AACA,iBAAiB,6DAAQ;AACzB;AACA;AACA;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA,6BAA6B,wEAA6B;AAC1D;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,sFAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAoC;AACxD;AACA;AACA;AACA,gBAAgB,+EAAoC;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;;;;;;;;;;;;;;;;;;;;;;;ACrE6C;AACL;AAC+B;AACN;AACI;AACE;AACA;AAC/B;AAC/C,sBAAsB,iFAAa;AACnC,uBAAuB,mFAAc;AACrC,uBAAuB,mFAAc;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iBAAiB,sGAAuC;AACxD;AACA;AACA,SAAS;AACT;AACA,iBAAiB,sGAAuC;AACxD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,0BAA0B,sEAAyB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,8EAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,8EAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,+BAA+B,wEAA2B;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B,8EAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gFAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,gFAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,oEAAuB,EAAE,KAAK,oEAAuB,EAAE,MAAM,wEAA2B;AAClH;AACA;AACA,kCAAkC,6EAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,wEAA2B;AAC9D,mCAAmC,wEAA2B;AAC9D;AACA;AACA,oCAAoC,sFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,oEAAuB;AAClD;AACA,2BAA2B,oEAAuB;AAClD,gCAAgC,oEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAqC;AAClE;AACA;AACA,8BAA8B,uEAA0B;AACxD,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAkC;AAChE,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA,6BAA6B,6EAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uEAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+EAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACpRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpDuC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,iCAAiC,2BAA2B;AAC5D,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD,6BAA6B,gCAAgC;AAC7D,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,6BAA6B,gCAAgC;AAC7D,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5JO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3LO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJO;AACP;AACA;;;;;;;;;;;;;;;;;ACF6C;AACtC;AACP;AACA;AACA,0BAA0B,0DAAU;AACpC,0BAA0B,0DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,0BAA0B,0DAAU;AACpC,0BAA0B,0DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;;;;;;;;;;;ACpEU;;;;;;;;;;;;;;;;;;;;ACA6C;AACZ;AACwB;AACpB;AACI;AACnD;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAQ;AACtB;AACA,mBAAmB,wDAAO;AAC1B,KAAK;AACL;AACA,mBAAmB,oDAAK;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,mBAAmB,4EAAiB;AACpC,KAAK;AACL;AACA,mBAAmB,gEAAW;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9C+B;AACU;AACN;AACY;AACV;AACA;AACK;AACA;AACE;AACJ;AACF;;;;;;;;;;;;;;;;;;;;ACVa;AACoC;AAC5B;AACoB;AACxE,2BAA2B,oEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE;AACA;AACA;AACA,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD;AACA;AACA;AACA,yBAAyB,gGAA2B,EAAE,kHAAwC;AAC9F;AACA;AACA,eAAe,iHAAuC,kBAAkB,gGAA2B;AACnG;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDuF;AACzB;AACJ;AACY;AACT;AACA;AACH;AACI;AACC;AACL;AACa;AACZ;AACpD,uBAAuB,kEAAY;AAC1C;AACA,qBAAqB,sEAAa;AAClC,gCAAgC,sEAAa;AAC7C,6BAA6B,wEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAS;AACpB;AACA,2BAA2B,iHAAuC;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA;AACA;AACA,eAAe,0FAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA,4CAA4C,wFAAsB;AAClE;AACA,iCAAiC,2FAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAoB;AACnC;AACA;AACA,2BAA2B,4EAAoB;AAC/C;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,qFAAmB,EAAE,sEAAgB,CAAC,qFAAmB;AACvH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,wFAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,mBAAmB,8FAAqC,UAAU,uFAAqB,EAAE,sEAAgB,CAAC,uFAAqB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,sFAAoB,EAAE,sEAAgB,CAAC,sFAAoB;AACzH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,sFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,8FAAqC,UAAU,wFAAsB,EAAE,sEAAgB,CAAC,wFAAsB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,gCAAgC,6FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+FAAsC;AACzD;AACA,eAAe,+FAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7TA;AACqE;AACF;AACK;AACE;AACT;AAC1D,4BAA4B,6EAAuB;AAC1D,WAAW,qEAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAgC;AACxC,sBAAsB,iFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACnEA;AACqE;AACG;AACF;AACH;AAC5D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB,GAAG,6EAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnEA;AACqE;AAClB;AACc;AAC1D;AACP,4BAA4B,4DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,cAAc;AACd;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC,6FAAqC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AClFA;AACqE;AACG;AACF;AAC/D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA","sources":["webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Classes/TagManagerBase.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/DivineBinaryTags.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/RemoteTagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/TagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/DBTSchema.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/Util.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Util/DBTUtil.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/index.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/AsyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/SyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Hooks.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/DataSync.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/ChunkTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/VoxelTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/WorldDataTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Util/CardinalNeighbors.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataHooks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Light/LightByte.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Register/Register.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelPalette.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelReader.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Chunk/ChunkTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Column/ColumnTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Dimensions/DimensionsRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionHeaderRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldPainter.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/BoundingBox.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/Plane.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/SimpleBoundingBox.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/Vector3.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/Distance2d.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/Distance3d.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/DistnaceSort.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/VisitAll.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Types/Math.types.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/VoxelMath.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/DataToolBase.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/LocationBoundTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/DataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ChunkDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ColumnDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/HeightMapTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/RegionDataTool.js"],"sourcesContent":["import { DBTUtil, TagNodeTypes } from \"../Util/DBTUtil.js\";\r\nconst TagIndexData = [0, 0, 0, 0];\r\nconst getIndexData = (data, indexBufferIndex) => {\r\n    TagIndexData[0] = data.getUint32(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\r\n    TagIndexData[1] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    TagIndexData[2] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    TagIndexData[3] = data.getUint8(indexBufferIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    return TagIndexData;\r\n};\r\nexport class TagManagerBase {\r\n    id;\r\n    byteOffSet = 0;\r\n    tagSize = 0;\r\n    tagIndexes = 0;\r\n    data = new DataView(new ArrayBuffer(0));\r\n    indexMap = new Map();\r\n    index = new DataView(new ArrayBuffer(0));\r\n    constructor(id) {\r\n        this.id = id;\r\n    }\r\n    setBuffer(data) {\r\n        if (data instanceof DataView) {\r\n            this.data = data;\r\n            return;\r\n        }\r\n        this.data = new DataView(data);\r\n    }\r\n    getBuffer() {\r\n        if (this.data instanceof DataView) {\r\n            return this.data.buffer;\r\n        }\r\n        return this.data;\r\n    }\r\n    setTagIndex(index) {\r\n        this.byteOffSet = index * this.tagSize;\r\n    }\r\n    getTag(id) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.boolean ||\r\n            indexData[3] == TagNodeTypes.number) {\r\n            return DBTUtil.getBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], indexData[2]);\r\n        }\r\n        if (indexData[3] == TagNodeTypes.typedNumber) {\r\n            return DBTUtil.getTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2]);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    setTag(id, value) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.boolean ||\r\n            indexData[3] == TagNodeTypes.number) {\r\n            this.data.setUint8(indexData[0] + this.byteOffSet, DBTUtil.setBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], value, indexData[2]));\r\n            return true;\r\n        }\r\n        if (indexData[3] == TagNodeTypes.typedNumber) {\r\n            DBTUtil.setTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2], value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getArrayTagValue(id, index) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return DBTUtil.getTypedNumber(this.data, indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2]);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    /**## getArrayTagByteIndex\r\n     *  Get the actual byte index for the provided index of the array.\r\n     * @param id\r\n     * @param index\r\n     * @returns\r\n     */\r\n    getArrayTagByteIndex(id, index) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return (indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]));\r\n        }\r\n        return -Infinity;\r\n    }\r\n    setArrayTagValue(id, index, value) {\r\n        const byteIndex = this.indexMap.get(id);\r\n        if (byteIndex === undefined) {\r\n            throw new Error(`Tag with id: ${id} does not exist.`);\r\n        }\r\n        const indexData = getIndexData(this.index, byteIndex);\r\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\r\n            return DBTUtil.setTypedNumber(this.data, indexData[0] +\r\n                this.byteOffSet +\r\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2], value);\r\n        }\r\n        return -Infinity;\r\n    }\r\n    loopThroughTags(run) {\r\n        this.indexMap.forEach((i, id) => {\r\n            run(id, this.getTag(id));\r\n        });\r\n    }\r\n    loopThroughIndex(run) {\r\n        this.indexMap.forEach((index, id) => {\r\n            const indexData = getIndexData(this.index, index);\r\n            run(indexData);\r\n        });\r\n    }\r\n    loopThroughAllIndexTags(run) {\r\n        for (let index = 0; index < this.tagIndexes; index++) {\r\n            this.setTagIndex(index);\r\n            this.indexMap.forEach((i, id) => {\r\n                run(id, this.getTag(id), index);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import { RemoteTagManager } from \"./RemoteTagManager.js\";\r\nimport { TagManager } from \"./TagManager.js\";\r\nexport const DivineBinaryTags = {\r\n    createTagManager(id) {\r\n        return new TagManager(id);\r\n    },\r\n    createRemoteTagManager(id) {\r\n        return new RemoteTagManager(id);\r\n    },\r\n};\r\n","import { TagManagerBase } from \"./Classes/TagManagerBase.js\";\r\nexport class RemoteTagManager extends TagManagerBase {\r\n    id;\r\n    initData;\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    $INIT(data) {\r\n        this.data = new DataView(data.buffer);\r\n        this.index = new DataView(data.indexBuffer);\r\n        this.indexMap = data.indexMap;\r\n        this.tagIndexes = data.totalIndexes;\r\n        this.tagSize = data.tagSize;\r\n        this.initData = data;\r\n    }\r\n}\r\n","import { DBTUtil, TagNodeTypes, NumberTypeRecord } from \"./Util/DBTUtil.js\";\r\nimport { TagManagerBase } from \"./Classes/TagManagerBase.js\";\r\nconst TagIndexSize = DBTUtil.getTypedSize(\"32ui\") + DBTUtil.getTypedSize(\"8ui\") * 3;\r\nconst setIndexData = (data, indexBufferIndex, byteIndex, bitOffSet, bitSize, type) => {\r\n    data.setUint32(indexBufferIndex, byteIndex);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\r\n    data.setUint8(indexBufferIndex, bitOffSet);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    data.setUint8(indexBufferIndex, bitSize);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    data.setUint8(indexBufferIndex, type);\r\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\r\n    return indexBufferIndex;\r\n};\r\nexport class TagManager extends TagManagerBase {\r\n    id;\r\n    schema = new Map();\r\n    initData = {};\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    registerTag(tagData) {\r\n        this.schema.set(tagData.id, tagData);\r\n    }\r\n    $INIT(initData) {\r\n        /*\r\n    [Process Tags]\r\n    */\r\n        const headers = new Map();\r\n        const booleans = [];\r\n        const numbers = [];\r\n        const typedNumbers = new Map();\r\n        const typedNumbersArrays = new Map();\r\n        this.schema.forEach((tag) => {\r\n            if (tag.type == \"header\") {\r\n                let tags = headers.get(tag.numberType);\r\n                if (!tags) {\r\n                    tags = [];\r\n                    headers.set(tag.numberType, tags);\r\n                }\r\n                tags.push(tag);\r\n            }\r\n            if (tag.type == \"boolean\") {\r\n                booleans.push(tag);\r\n            }\r\n            if (tag.type == \"number\") {\r\n                const range = tag.range;\r\n                const bitSize = DBTUtil.calculateBitsNeeded(range[0], range[1]);\r\n                numbers[bitSize] ??= [];\r\n                numbers[bitSize].push(tag);\r\n            }\r\n            if (tag.type == \"typed-number\") {\r\n                let tags = typedNumbers.get(tag.numberType);\r\n                if (!tags) {\r\n                    tags = [];\r\n                    typedNumbers.set(tag.numberType, tags);\r\n                }\r\n                tags.push(tag);\r\n            }\r\n            if (tag.type == \"typed-number-array\") {\r\n                let arrayTags = typedNumbersArrays.get(tag.numberType);\r\n                if (!arrayTags) {\r\n                    arrayTags = [];\r\n                    typedNumbersArrays.set(tag.numberType, arrayTags);\r\n                }\r\n                arrayTags.push(tag);\r\n            }\r\n        });\r\n        /*\r\n    [Build Index]\r\n    */\r\n        const indexSize = this.schema.size * TagIndexSize;\r\n        let indexBuffer = new ArrayBuffer(indexSize);\r\n        if (initData?.indexBufferMode == \"shared\") {\r\n            indexBuffer = new SharedArrayBuffer(indexSize);\r\n        }\r\n        const index = new DataView(indexBuffer);\r\n        this.index = index;\r\n        let indexBufferIndex = 0;\r\n        let byteIndex = 0;\r\n        let bitIndex = 0;\r\n        let bitSize = 1;\r\n        /*\r\n    [Headers]\r\n    */\r\n        headers.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\r\n                byteIndex += byteSise;\r\n            }\r\n        });\r\n        /*\r\n    [Booleans]\r\n    */\r\n        bitSize = 1;\r\n        for (let i = 0; i < booleans.length; i++) {\r\n            const bool = booleans[i];\r\n            this.indexMap.set(bool.id, indexBufferIndex);\r\n            indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.boolean);\r\n            bitIndex++;\r\n            if (bitIndex >= 8) {\r\n                byteIndex++;\r\n                bitIndex = 0;\r\n            }\r\n        }\r\n        /*\r\n    [Ranged Numbers]\r\n    */\r\n        byteIndex++;\r\n        bitIndex = 0;\r\n        let cachedBitSize = 0;\r\n        numbers.forEach((tags, bitS) => {\r\n            bitSize = bitS;\r\n            if (cachedBitSize != bitSize) {\r\n                byteIndex++;\r\n                bitIndex = 0;\r\n            }\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.number);\r\n                bitIndex += bitSize;\r\n                if (bitIndex >= 8) {\r\n                    byteIndex++;\r\n                    bitIndex = 0;\r\n                }\r\n            }\r\n        });\r\n        /*\r\n    [Typed Numbers]\r\n    */\r\n        bitIndex = 0;\r\n        byteIndex++;\r\n        typedNumbers.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\r\n                byteIndex += byteSise;\r\n            }\r\n        });\r\n        /*\r\n    [Typed Numbers Arrays]\r\n    */\r\n        byteIndex++;\r\n        typedNumbersArrays.forEach((tags, type) => {\r\n            const byteSise = DBTUtil.getTypedSize(type);\r\n            for (let i = 0; i < tags.length; i++) {\r\n                const tag = tags[i];\r\n                this.indexMap.set(tag.id, indexBufferIndex);\r\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumberArray);\r\n                byteIndex += byteSise * tag.length;\r\n            }\r\n        });\r\n        /*\r\n    [Create Remote Tag Manager Data]\r\n    */\r\n        let numberOfIndexes = 1;\r\n        if (initData?.numberOfIndexes) {\r\n            numberOfIndexes = initData.numberOfIndexes;\r\n        }\r\n        this.tagIndexes = numberOfIndexes;\r\n        this.tagSize = byteIndex;\r\n        const remoteData = {\r\n            bufferSize: byteIndex * numberOfIndexes,\r\n            buffer: new ArrayBuffer(0),\r\n            indexBuffer: indexBuffer,\r\n            indexMap: this.indexMap,\r\n            tagSize: this.tagSize,\r\n            totalIndexes: numberOfIndexes,\r\n        };\r\n        this.initData = remoteData;\r\n        return remoteData;\r\n    }\r\n}\r\n","export {};\r\n","export {};\r\n","export const TagNodeTypes = {\r\n    boolean: 0,\r\n    number: 1,\r\n    typedNumber: 2,\r\n    typedNumberArray: 3,\r\n};\r\nconst NumberTypeByteSize = {\r\n    \"8ui\": 1,\r\n    \"8i\": 1,\r\n    \"16ui\": 2,\r\n    \"16i\": 2,\r\n    \"32ui\": 4,\r\n    \"32i\": 4,\r\n    \"32f\": 4,\r\n    \"64f\": 8,\r\n    \"64i\": 8,\r\n    \"64ui\": 8,\r\n};\r\nexport const NumberTypeRecord = {\r\n    \"8ui\": 0,\r\n    \"8i\": 1,\r\n    \"16ui\": 2,\r\n    \"16i\": 3,\r\n    \"32ui\": 4,\r\n    \"32i\": 5,\r\n    \"32f\": 6,\r\n    \"64f\": 7,\r\n    \"64i\": 8,\r\n    \"64ui\": 9,\r\n};\r\nexport const NumberTypeMap = {};\r\nfor (const key of Object.keys(NumberTypeRecord)) {\r\n    //@ts-ignore\r\n    NumberTypeMap[Number(NumberTypeRecord[key])] = key;\r\n}\r\nconst TypedNumberSetFunctions = {\r\n    \"8ui\": (data, index, value) => {\r\n        data.setUint8(index, value);\r\n    },\r\n    \"8i\": (data, index, value) => {\r\n        data.setInt8(index, value);\r\n    },\r\n    \"16ui\": (data, index, value) => {\r\n        data.setUint16(index, value);\r\n    },\r\n    \"16i\": (data, index, value) => {\r\n        data.setInt16(index, value);\r\n    },\r\n    \"32ui\": (data, index, value) => {\r\n        data.setUint32(index, value);\r\n    },\r\n    \"32i\": (data, index, value) => {\r\n        data.setInt32(index, value);\r\n    },\r\n    \"32f\": (data, index, value) => {\r\n        data.setFloat32(index, value);\r\n    },\r\n    \"64f\": (data, index, value) => {\r\n        data.setFloat64(index, value);\r\n    },\r\n    \"64i\": (data, index, value) => {\r\n        data.setBigUint64(index, BigInt(value));\r\n    },\r\n    \"64ui\": (data, index, value) => {\r\n        data.setBigUint64(index, BigInt(value));\r\n    },\r\n};\r\nconst TypedNumberGetFunctions = {\r\n    \"8ui\": (data, index) => {\r\n        return data.getUint8(index);\r\n    },\r\n    \"8i\": (data, index) => {\r\n        return data.getInt8(index);\r\n    },\r\n    \"16ui\": (data, index) => {\r\n        return data.getUint16(index);\r\n    },\r\n    \"16i\": (data, index) => {\r\n        return data.getInt16(index);\r\n    },\r\n    \"32ui\": (data, index) => {\r\n        return data.getUint32(index);\r\n    },\r\n    \"32i\": (data, index) => {\r\n        return data.getInt32(index);\r\n    },\r\n    \"32f\": (data, index) => {\r\n        return data.getFloat32(index);\r\n    },\r\n    \"64f\": (data, index) => {\r\n        return data.getFloat64(index);\r\n    },\r\n    \"64i\": (data, index) => {\r\n        return Number(data.getBigUint64(index));\r\n    },\r\n    \"64ui\": (data, index) => {\r\n        return Number(data.getBigUint64(index));\r\n    },\r\n};\r\nexport const DBTUtil = {\r\n    setTypedNumber(data, index, numberType, value) {\r\n        TypedNumberSetFunctions[NumberTypeMap[numberType]](data, index, value);\r\n    },\r\n    getTypedNumber(data, index, numberType) {\r\n        return TypedNumberGetFunctions[NumberTypeMap[numberType]](data, index);\r\n    },\r\n    calculateBitsNeeded(min, max) {\r\n        let range = max - min;\r\n        return Math.ceil(Math.log2(range));\r\n    },\r\n    getTypedSize(type) {\r\n        return NumberTypeByteSize[type];\r\n    },\r\n    getTypedSizeFromNumber(t) {\r\n        return NumberTypeByteSize[NumberTypeMap[t]];\r\n    },\r\n    getBitValue(data, index, bitSize) {\r\n        index *= bitSize;\r\n        const mask = 2 ** bitSize - 1;\r\n        return ((mask << index) & data) >>> index;\r\n    },\r\n    setBitValue(data, index, value, bitSize) {\r\n        index *= bitSize;\r\n        const mask = 2 ** bitSize - 1;\r\n        return (data & ~(mask << index)) | ((value & mask) << index);\r\n    },\r\n};\r\n","export * from \"./DivineBinaryTags.js\";\r\nexport * from \"./RemoteTagManager.js\";\r\nexport * from \"./TagManager.js\";\r\nexport * from \"./Classes/TagManagerBase.js\";\r\nexport * from \"./Types/DBTSchema.types.js\";\r\nexport * from \"./Types/Util.types.js\";\r\nexport * from \"./Util/DBTUtil.js\";\r\n","export class AsyncHook {\r\n    _onRun = [];\r\n    async run(data) {\r\n        let returnData = false;\r\n        for (const run of this._onRun) {\r\n            returnData = await run(data);\r\n        }\r\n        return returnData;\r\n    }\r\n    addToRun(run) {\r\n        this._onRun.push(run);\r\n    }\r\n}\r\n","export class SyncHook {\r\n    _onRun = [];\r\n    run(data) {\r\n        let returnData = false;\r\n        for (const run of this._onRun) {\r\n            returnData = run(data);\r\n        }\r\n        return returnData;\r\n    }\r\n    addToRun(run) {\r\n        this._onRun.push(run);\r\n    }\r\n}\r\n","import { AsyncHook } from \"./Classes/AsyncHook.js\";\r\nimport { SyncHook } from \"./Classes/SyncHook.js\";\r\nexport const Hooks = {\r\n    getAsyncHook() {\r\n        return new AsyncHook();\r\n    },\r\n    getSyncHook() {\r\n        return new SyncHook();\r\n    },\r\n};\r\n","export * from \"./Hooks.js\";\r\n","export const DataSyncTypes = {\r\n    chunk: 0,\r\n    column: 1,\r\n    region: 2,\r\n    regionHeader: 2,\r\n    voxelPalette: 3,\r\n    voxelTags: 4,\r\n    materials: 4,\r\n    colliders: 4,\r\n    dimesnion: 5,\r\n    chunkTags: 6,\r\n    columnTags: 7,\r\n    regionTags: 8,\r\n    registerStringMap: 0,\r\n};\r\nlet index = 0;\r\nfor (const key of Object.keys(DataSyncTypes)) {\r\n    DataSyncTypes[key] = index;\r\n    index++;\r\n}\r\n","export const ChunkTagIDs = {\r\n    minHeight: \"#dve_min_height\",\r\n    maxHeight: \"#dve_max_height\",\r\n    heightMap: \"#dve_height_map\",\r\n    voxelIDSegment: \"#dve_voxel_id\",\r\n    voxelLightSegment: \"#dve_voxel_light\",\r\n    voxelStateSegment: \"#dve_voxel_state\",\r\n    voxelSecondaryIDSegment: \"#dve_voxel_secondary_id\",\r\n};\r\n","export const VoxelTagIDs = {\r\n    substance: \"#dve_substance\",\r\n    shapeID: \"#dve_shape_id\",\r\n    material: \"#dve_material\",\r\n    hardness: \"#dve_hardness\",\r\n    colliderID: \"#dve_collider_id\",\r\n    checkCollisions: \"#dve_check_collisions\",\r\n    isLightSource: \"#dve_is_light_source\",\r\n    lightValue: \"#dve_light_value\",\r\n    isRich: \"#dve_is_rich\",\r\n};\r\n","export const WorldDataTagIDs = {\r\n    header: \"#dve_header\",\r\n    dataType: \"#dve_data_type\",\r\n    dimensionId: \"#dve_dimension_id\",\r\n    positionX: \"#dve_p_x\",\r\n    positionY: \"#dve_p_y\",\r\n    positionZ: \"#dve_p_z\",\r\n};\r\n","export const $3dMooreNeighborhood = [];\r\nexport const $2dMooreNeighborhood = [\r\n    [0, 0],\r\n    [1, 0],\r\n    [0, 1],\r\n    [1, 1],\r\n    [-1, 0],\r\n    [0, -1],\r\n    [-1, -1],\r\n    [1, -1],\r\n    [-1, 1],\r\n];\r\nexport const $3dCardinalNeighbors = [\r\n    [0, 1, 0],\r\n    [0, -1, 0],\r\n    [1, 0, 0],\r\n    [-1, 0, 0],\r\n    [0, 0, -1],\r\n    [0, 0, 1],\r\n];\r\nfor (let y = -1; y < 2; y++) {\r\n    for (const n of $2dMooreNeighborhood) {\r\n        $3dMooreNeighborhood.push([n[0], y, n[1]]);\r\n    }\r\n}\r\n","import { Hooks } from \"divine-hooks\";\r\nexport const DataHooks = {\r\n    dimension: {\r\n        onRegisterDimension: Hooks.getSyncHook(),\r\n    },\r\n    chunk: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    column: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    region: {\r\n        onGetAsync: Hooks.getAsyncHook(),\r\n        onGetSync: Hooks.getSyncHook(),\r\n        onNew: Hooks.getAsyncHook(),\r\n        onRemove: Hooks.getSyncHook(),\r\n    },\r\n    paint: {\r\n        onAddToRGBUpdate: Hooks.getSyncHook(),\r\n        onRichVoxelPaint: Hooks.getSyncHook(),\r\n    },\r\n    settingsSynced: Hooks.getSyncHook(),\r\n};\r\n","import { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\r\nimport { Register } from \"./Register/Register.js\";\r\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\r\nimport { WorldBounds } from \"./World/WorldBounds.js\";\r\nimport { WorldPainter } from \"./World/WorldPainter.js\";\r\nimport { WorldRegister } from \"./World/WorldRegister.js\";\r\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\r\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\r\nimport { RegionTags } from \"./World/Region/RegionTags.js\";\r\nimport { WorldSpaces } from \"./World/WorldSpaces.js\";\r\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\r\nexport const DataManager = {\r\n    dimensions: DimensionsRegister,\r\n    voxelTags: VoxelTags,\r\n    world: WorldPainter,\r\n    worldRegister: WorldRegister,\r\n    columnTags: ColumnTags,\r\n    worldBounds: WorldBounds,\r\n    spaces: WorldSpaces,\r\n    register: Register,\r\n    chunkTags: ChunkTags,\r\n    regionTags: RegionTags,\r\n    regionHeaderReigster: RegionHeaderRegister,\r\n};\r\n","/**# Light Byte\r\n * ---\r\n * Used to decode light color info.\r\n */\r\nexport const LightData = {\r\n    SRS: 2,\r\n    _lightValues: [0, 0, 0, 0],\r\n    getS(value) {\r\n        return value & 0xf;\r\n    },\r\n    getR(value) {\r\n        return (value & (0xf << 4)) >> 4;\r\n    },\r\n    getG(value) {\r\n        return (value & (0xf << 8)) >> 8;\r\n    },\r\n    getB(value) {\r\n        return (value & (0xf << 12)) >> 12;\r\n    },\r\n    setS(value, sl) {\r\n        return (sl & ~0xf) | value;\r\n    },\r\n    setR(value, sl) {\r\n        return (sl & ~(0xf << 4)) | (value << 4);\r\n    },\r\n    setG(value, sl) {\r\n        return (sl & ~(0xf << 8)) | (value << 8);\r\n    },\r\n    setB(value, sl) {\r\n        return (sl & ~(0xf << 12)) | (value << 12);\r\n    },\r\n    removeS(sl) {\r\n        return this.setS(0, sl);\r\n    },\r\n    hasRGBLight(sl) {\r\n        if (sl <= 0)\r\n            return false;\r\n        if (this.getR(sl) > 0)\r\n            return true;\r\n        if (this.getG(sl) > 0)\r\n            return true;\r\n        if (this.getB(sl) > 0)\r\n            return true;\r\n        return false;\r\n    },\r\n    hasSunLight(sl) {\r\n        if (sl <= 0)\r\n            return false;\r\n        if (this.getS(sl) > 0)\r\n            return true;\r\n        return false;\r\n    },\r\n    mixLight(l1, l2) {\r\n        const s1 = this.getS(l1);\r\n        const s2 = this.getS(l2);\r\n        const s = s1 < s2 ? s2 : s1;\r\n        const r1 = this.getR(l1);\r\n        const r2 = this.getR(l2);\r\n        const r = r1 < r2 ? r2 : r1;\r\n        const g1 = this.getG(l1);\r\n        const g2 = this.getG(l2);\r\n        const g = g1 < g2 ? g2 : g1;\r\n        const b1 = this.getB(l1);\r\n        const b2 = this.getB(l2);\r\n        const b = b1 < b2 ? b2 : b1;\r\n        let nl = this.setS(s, 0);\r\n        nl = this.setR(r, nl);\r\n        nl = this.setG(g, nl);\r\n        nl = this.setB(b, nl);\r\n        return nl;\r\n    },\r\n    getRGB(sl) {\r\n        if (sl < 0)\r\n            return 0;\r\n        return (sl & 0xfff0) >> 4;\r\n    },\r\n    setRGB(value, sl) {\r\n        if (sl < 0)\r\n            return 0;\r\n        return (sl & ~0xfff0) | (value << 4);\r\n    },\r\n    decodeLightFromVoxelData(voxelData) {\r\n        return (voxelData & (0xffff << 0)) >> 0;\r\n    },\r\n    encodeLightIntoVoxelData(voxelData, encodedLight) {\r\n        return (voxelData & ~(0xffff << 0)) | (encodedLight << 0);\r\n    },\r\n    /**# Set Light Values\r\n     * ---\r\n     * Give an array of light values it will return an encoded light number.\r\n     * @param values\r\n     */\r\n    setLightValues(values) {\r\n        let value = this.setS(values[0], 0);\r\n        value = this.setR(values[1], value);\r\n        value = this.setG(values[2], value);\r\n        return this.setB(values[3], value);\r\n    },\r\n    /**# Get Light Values\r\n     * ---\r\n     * Given an encoded light number it will return an array of its values.\r\n     * - 0: Sun Light\r\n     * - 1: Red Light\r\n     * - 2: Green Light\r\n     * - 3: Blue Light\r\n     * @param value\r\n     */\r\n    getLightValues(value) {\r\n        this._lightValues[0] = this.getS(value);\r\n        this._lightValues[1] = this.getR(value);\r\n        this._lightValues[2] = this.getG(value);\r\n        this._lightValues[3] = this.getB(value);\r\n        return this._lightValues;\r\n    },\r\n    /**# Is Less Than For RGB Remove\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light remove.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForRGBRemove(n1, n2) {\r\n        let r1 = this.getR(n1);\r\n        let g1 = this.getG(n1);\r\n        let b1 = this.getB(n1);\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 < r2 || g1 < g2 || b1 < b2;\r\n    },\r\n    /**# Is Less Than For RGB Add\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light add.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForRGBAdd(n1, n2) {\r\n        let r1 = this.getR(n1) + 2;\r\n        let g1 = this.getG(n1) + 2;\r\n        let b1 = this.getB(n1) + 2;\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 <= r2 || g1 <= g2 || b1 <= b2;\r\n    },\r\n    /**# Is Greater Or Equal Than For RGB Remove\r\n     * ---\r\n     * Compares values for the RGB encoded light values.\r\n     * Used for RGB light remove.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isGreaterOrEqualThanForRGBRemove(n1, n2) {\r\n        let r1 = this.getR(n1);\r\n        let g1 = this.getG(n1);\r\n        let b1 = this.getB(n1);\r\n        let r2 = this.getR(n2);\r\n        let g2 = this.getG(n2);\r\n        let b2 = this.getB(n2);\r\n        return r1 >= r2 || g1 >= g2 || b1 >= b2;\r\n    },\r\n    /**# Get Minus One For RGB\r\n     * ---\r\n     * Returns the RGB light values minus one.\r\n     * @param sl - source light value\r\n     */\r\n    getMinusOneForRGB(sl, nl) {\r\n        let s = this.getS(nl);\r\n        let r = this.getR(sl) - 1;\r\n        if (r < 0)\r\n            r = 0;\r\n        let rn = this.getR(nl);\r\n        if (r < rn) {\r\n            r = rn;\r\n        }\r\n        let g = this.getG(sl) - 1;\r\n        if (g < 0)\r\n            g = 0;\r\n        let gn = this.getG(nl);\r\n        if (g < gn) {\r\n            g = gn;\r\n        }\r\n        let b = this.getB(sl) - 1;\r\n        if (b < 0)\r\n            b = 0;\r\n        let bn = this.getB(nl);\r\n        if (b < bn) {\r\n            b = bn;\r\n        }\r\n        let bv = 0;\r\n        bv = this.setS(s, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Remove RGB Light\r\n     * ---\r\n     * Removes all RGB light from an encoded light value.\r\n     * @param sl - source light value\r\n     */\r\n    removeRGBLight(sl) {\r\n        let s = this.getS(sl);\r\n        let bv = 0;\r\n        bv = this.setR(0, bv);\r\n        bv = this.setG(0, bv);\r\n        bv = this.setB(0, bv);\r\n        bv = this.setS(s, bv);\r\n        return bv;\r\n    },\r\n    /**# Get Full Sun Light\r\n     * --\r\n     * Alters the encoded light number passed to it to give it full sun light.\r\n     * @param sl - source light value\r\n     */\r\n    getFullSunLight(sl) {\r\n        return sl | 0b1111;\r\n    },\r\n    /**# Is Less Than For Sun Add\r\n     * ---\r\n     * Used to calculate sun light addition.\r\n     * Used to check all neighbors expect down.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForSunAdd(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    /**# Is Less Than For Sun Add Down\r\n     *\r\n     * Used to calculate sun light addition.\r\n     * Used to check only the down neighbor.\r\n     * @param n1\r\n     * @param n2\r\n     */\r\n    isLessThanForSunAddDown(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        if (sl2 == 0xf) {\r\n            return sl1 < sl2;\r\n        }\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    isLessThanForSunAddUp(n1, n2) {\r\n        let sl1 = this.getS(n1);\r\n        let sl2 = this.getS(n2);\r\n        if (sl1 == sl2)\r\n            return false;\r\n        if (sl2 == 0xf || sl1 == 0xf)\r\n            return false;\r\n        return sl1 + this.SRS < sl2;\r\n    },\r\n    /**# Get Sun Light For Under Voxel\r\n     * ---\r\n     * Gets the sun light value for sun light addition when setting the\r\n     * down neighbor.\r\n     * @param currentVoxel\r\n     */\r\n    getSunLightForUnderVoxel(sl, nl) {\r\n        let s = this.getS(sl);\r\n        let sn = this.getS(nl);\r\n        if (s == 15) {\r\n            sn = s;\r\n        }\r\n        if (s < 15) {\r\n            sn = s - this.SRS;\r\n        }\r\n        let r = this.getR(nl);\r\n        let g = this.getG(nl);\r\n        let b = this.getB(nl);\r\n        let bv = 0;\r\n        bv = this.setS(sn, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Get Minus One For Sun\r\n     * ---\r\n     * Returns the sun light level passed to it minus one.\r\n     * Used for sun light addition on all neighbors expect the down one.\r\n     * @param sl - source light value\r\n     */\r\n    getMinusOneForSun(sl, nl) {\r\n        let s = this.getS(sl) - this.SRS;\r\n        if (s < 0)\r\n            s = 0;\r\n        let sn = this.getS(nl);\r\n        if (s < sn) {\r\n            s = sn;\r\n        }\r\n        let r = this.getR(nl);\r\n        let g = this.getG(nl);\r\n        let b = this.getB(nl);\r\n        let bv = 0;\r\n        bv = this.setS(s, bv);\r\n        bv = this.setR(r, bv);\r\n        bv = this.setG(g, bv);\r\n        bv = this.setB(b, bv);\r\n        return bv;\r\n    },\r\n    /**# Is Less Than For Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    isLessThanForSunRemove(n1, sl) {\r\n        let s1 = this.getS(n1);\r\n        let s2 = this.getS(sl);\r\n        return s1 < s2;\r\n    },\r\n    /**# Is Greater Or Equal Than For Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    isGreaterOrEqualThanForSunRemove(n1, sl) {\r\n        let s1 = this.getS(n1);\r\n        let s2 = this.getS(sl);\r\n        return s1 >= s2;\r\n    },\r\n    /**# Sun Light Compare For Down Sun Remove\r\n     * ---\r\n     * Compares two encoded light values sun light values.\r\n     * Used for sun light removal in the downward direction only.\r\n     * @param n1\r\n     * @param sl - source light value\r\n     */\r\n    sunLightCompareForDownSunRemove(n1, sl) {\r\n        let s2 = this.getS(sl);\r\n        if (s2 == 0xf)\r\n            return true;\r\n        let s1 = this.getS(n1);\r\n        return s1 < s2;\r\n    },\r\n    /**# Remove Sun Light\r\n     * ---\r\n     * Removes the sun light from a light encoded value.\r\n     * @param sl - source light value\r\n     */\r\n    removeSunLight(sl) {\r\n        return this.removeS(sl);\r\n    },\r\n    minusOneForAll(sl) {\r\n        let s = this.getS(sl) - this.SRS;\r\n        let r = this.getR(sl) - 1;\r\n        let g = this.getG(sl) - 1;\r\n        let b = this.getB(sl) - 1;\r\n        if (s < 0)\r\n            s = 0;\r\n        if (r < 0)\r\n            r = 0;\r\n        if (g < 0)\r\n            g = 0;\r\n        if (b < 0)\r\n            b = 0;\r\n        let nl = this.setS(s, 0);\r\n        nl = this.setR(r, nl);\r\n        nl = this.setG(g, nl);\r\n        nl = this.setB(b, nl);\r\n        return nl;\r\n    },\r\n};\r\n","export const Register = {\r\n    stringMaps: {\r\n        segments: new Map(),\r\n        syncStringMap(data) {\r\n            const [segment, id, value] = data;\r\n            let segmentMap = this.segments.get(segment);\r\n            if (!segmentMap) {\r\n                segmentMap = new Map();\r\n                this.segments.set(segment, segmentMap);\r\n            }\r\n            segmentMap.set(id, value);\r\n            return;\r\n        },\r\n        getStringMapValue(segment, id, index) {\r\n            const segmentMap = this.segments.get(segment);\r\n            if (!segmentMap)\r\n                return \"\";\r\n            const map = segmentMap.get(id);\r\n            if (!map) {\r\n                // throw new Error(`${id} does not exists`);\r\n                return \"\";\r\n            }\r\n            return map[index];\r\n        },\r\n    },\r\n};\r\nRegister.stringMaps.segments.set(\"voxel\", new Map());\r\n","export const VoxelPaletteReader = {\r\n    _palette: [\"dve_air\", \"dve_barrier\"],\r\n    _map: new Map(),\r\n    setVoxelPalette(voxelPalette, voxelPaletteMap) {\r\n        this._palette = voxelPalette;\r\n        this._map = new Map(Object.entries(voxelPaletteMap));\r\n    },\r\n    id: {\r\n        stringFromNumber(id) {\r\n            return VoxelPaletteReader._palette[id];\r\n        },\r\n        numberFromString(id) {\r\n            return VoxelPaletteReader._map.get(id);\r\n        },\r\n        getPaletteId(voxelId, voxelState) {\r\n            const numericID = VoxelPaletteReader._map.get(voxelId);\r\n            if (numericID == undefined)\r\n                return -1;\r\n            const stateId = voxelState + numericID;\r\n            if (VoxelPaletteReader._palette[stateId] != voxelId) {\r\n                throw new Error(`${voxelState} is not a valid state for voxel with id : ${voxelId}`);\r\n            }\r\n            if (stateId) {\r\n                return stateId;\r\n            }\r\n            return -1;\r\n        },\r\n        baseNumeric(id) {\r\n            if (id < 2)\r\n                return id;\r\n            const vid = this.numberFromString(this.stringFromNumber(id));\r\n            if (!vid)\r\n                return -1;\r\n            return vid;\r\n        },\r\n    },\r\n};\r\n","const voxelStateMasks = {\r\n    level: 0b00_1111,\r\n    levelState: 0b11_0000,\r\n    shapeState: 0b1111_1111_11_00_0000,\r\n};\r\n/**# Voxel Byte\r\n * ---\r\n * Used to decode voxel data.\r\n */\r\nexport const VoxelReader = {\r\n    getLevel(stateData) {\r\n        return stateData & voxelStateMasks.level;\r\n    },\r\n    setLevel(stateData, level) {\r\n        return (stateData & ~voxelStateMasks.level) | level;\r\n    },\r\n    getLevelState(stateData) {\r\n        return (stateData & voxelStateMasks.levelState) >> 4;\r\n    },\r\n    setLevelState(stateData, levelState) {\r\n        return (stateData & ~voxelStateMasks.levelState) | (levelState << 4);\r\n    },\r\n    getShapeState(voxelData) {\r\n        return (voxelData & voxelStateMasks.shapeState) >> 6;\r\n    },\r\n    setShapeState(voxelData, shapeState) {\r\n        return (voxelData & ~voxelStateMasks.shapeState) | (shapeState << 6);\r\n    },\r\n};\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nclass VDTags extends RemoteTagManager {\r\n    id;\r\n    voxelIndex = new Uint16Array();\r\n    constructor(id) {\r\n        super(id);\r\n        this.id = id;\r\n    }\r\n    sync(voxelMap) {\r\n        this.voxelIndex = voxelMap;\r\n    }\r\n    setVoxel(id) {\r\n        const index = this.voxelIndex[id];\r\n        this.setTagIndex(index);\r\n    }\r\n}\r\nexport const VoxelTags = new VDTags(\"voxel-data\");\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const ChunkTags = new RemoteTagManager(\"chunk-tags\");\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const ColumnTags = new RemoteTagManager(\"column-tags\");\r\n","import { DataHooks } from \"../../DataHooks.js\";\r\nimport { WorldRegister } from \"../WorldRegister.js\";\r\nexport const DimensionsRegister = {\r\n    _count: 1,\r\n    dimensionRecord: {\r\n        main: 0,\r\n    },\r\n    dimensionMap: {\r\n        0: \"main\",\r\n    },\r\n    __defaultDimensionOptions: {\r\n        liquidFlowSpeed: 0.1,\r\n        magmaFlowSpeed: 0.1,\r\n        sunLight: true,\r\n    },\r\n    _dimensions: {},\r\n    registerDimension(id, option) {\r\n        if (!option) {\r\n            option = this.__defaultDimensionOptions;\r\n        }\r\n        const dimensionData = {\r\n            id: id,\r\n            options: option,\r\n        };\r\n        this._dimensions[id] = dimensionData;\r\n        this.dimensionRecord[id] = this._count;\r\n        this.dimensionMap[this._count] = id;\r\n        DataHooks.dimension.onRegisterDimension.run(dimensionData);\r\n        WorldRegister.dimensions.add(id);\r\n    },\r\n    getDimension(id) {\r\n        id = this.getDimensionStringId(id);\r\n        return this._dimensions[id];\r\n    },\r\n    getDimensionStringId(id) {\r\n        if (typeof id == \"number\") {\r\n            return this.dimensionMap[id];\r\n        }\r\n        return id;\r\n    },\r\n    getDimensionNumericId(id) {\r\n        if (typeof id == \"string\") {\r\n            return this.dimensionRecord[id];\r\n        }\r\n        return id;\r\n    },\r\n};\r\n","import { WorldSpaces } from \"../WorldSpaces.js\";\r\nimport { RegionHeaderTags } from \"./RegionTags.js\";\r\nexport const RegionHeaderRegister = {\r\n    _headers: new Map(),\r\n    remove(location) {\r\n        const [dimensionId, x, y, z] = location;\r\n        const dimension = this._headers.get(dimensionId);\r\n        if (!dimension)\r\n            return false;\r\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\r\n        return dimension.delete(regionKey);\r\n    },\r\n    add(location, buffer) {\r\n        const [dimensionId, x, y, z] = location;\r\n        let dimension = this._headers.get(dimensionId);\r\n        if (!dimension) {\r\n            dimension = new Map();\r\n            this._headers.set(dimensionId, dimension);\r\n        }\r\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\r\n        dimension.set(regionKey, {\r\n            buffer: buffer,\r\n            data: new DataView(buffer),\r\n        });\r\n    },\r\n    get(location) {\r\n        const [dimensionId, x, y, z] = location;\r\n        let dimension = this._headers.get(dimensionId);\r\n        if (!dimension)\r\n            return false;\r\n        return dimension.get(WorldSpaces.region.getKeyXYZ(x, y, z));\r\n    },\r\n    /**# isStored\r\n     * @param location\r\n     * @returns\r\n     *\r\n     * Returns 1 if stored\r\n     *\r\n     * Returns 0 if not stored\r\n     *\r\n     * Returns -1 if region header is not loaded\r\n     *\r\n     */\r\n    isStored(location) {\r\n        const header = this.get(location);\r\n        if (!header)\r\n            return -1;\r\n        RegionHeaderTags.setBuffer(header.data);\r\n        const columnIndex = WorldSpaces.column.getIndexXYZ(location[1], location[2], location[3]);\r\n        return RegionHeaderTags.getArrayTagValue(\"#dved-column-save-timestamp\", columnIndex) != 0\r\n            ? 1\r\n            : 0;\r\n    },\r\n};\r\n","import { RemoteTagManager } from \"divine-binary-tags\";\r\nexport const RegionTags = new RemoteTagManager(\"region-tags\");\r\nexport const RegionHeaderTags = new RemoteTagManager(\"region-header-tags\");\r\n","import { WorldRegister } from \"./WorldRegister.js\";\r\nimport { DataHooks } from \"../DataHooks.js\";\r\nimport { VoxelPaletteReader } from \"../Voxel/VoxelPalette.js\";\r\nimport { DataTool } from \"../../Tools/Data/DataTool.js\";\r\nconst WP = {\r\n    _currentionDimension: \"main\",\r\n    paint: {\r\n        _dt: new DataTool(),\r\n        voxel(location, data, update = true) {\r\n            if (!location[0]) {\r\n                location[0] = WP._currentionDimension;\r\n            }\r\n            let chunk = WorldRegister.chunk.get(location);\r\n            if (!chunk) {\r\n                let buffer = DataHooks.chunk.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                chunk = WorldRegister.chunk.add(location, buffer);\r\n            }\r\n            this.__paint(location, data, update);\r\n        },\r\n        __paint(location, data, update = true) {\r\n            this._dt.setLocation(location);\r\n            if (!this._dt.setLocation(location).loadIn())\r\n                return;\r\n            const id = VoxelPaletteReader.id.getPaletteId(data.id, data.state ? data.state : 0);\r\n            if (id < 0)\r\n                return false;\r\n            this._dt.setId(id);\r\n            this._dt.setShapeState(data.shapeState ? data.shapeState : 0);\r\n            const substance = this._dt.getSubstance();\r\n            if (substance == \"#dve_liquid\" || substance == \"#dve_magma\") {\r\n                this._dt.setLevel(15);\r\n            }\r\n            if (data.secondaryVoxelId && data.secondaryVoxelId != \"dve_air\") {\r\n                const vid = VoxelPaletteReader.id.getPaletteId(data.secondaryVoxelId, data.secondaryState ? data.secondaryState : 0);\r\n                if (vid > 0) {\r\n                    this._dt.setSecondary(true);\r\n                    this._dt.setId(vid);\r\n                    this._dt.setSecondary(false);\r\n                }\r\n            }\r\n            if (this._dt.isLightSource() && this._dt.getLightSourceValue()) {\r\n                this._dt.setLight(this._dt.getLightSourceValue());\r\n                if (update) {\r\n                    DataHooks.paint.onAddToRGBUpdate.run(location);\r\n                }\r\n            }\r\n            if (this._dt.isRich()) {\r\n                DataHooks.paint.onRichVoxelPaint.run([this._dt.getStringId(), location]);\r\n            }\r\n            this._dt.commit(1);\r\n        },\r\n        erase(location) {\r\n            this._dt.setLocation(location);\r\n            if (!this._dt.loadIn())\r\n                return;\r\n            if (!this._dt.isRenderable())\r\n                return;\r\n            this._dt\r\n                .setLight(0)\r\n                .setLevel(0)\r\n                .setLevelState(0)\r\n                .setShapeState(0)\r\n                .setAir()\r\n                .commit(2);\r\n        },\r\n    },\r\n};\r\nexport const WorldPainter = WP;\r\n","import { DataHooks } from \"../../Data/DataHooks.js\";\r\nimport { WorldBounds } from \"./WorldBounds.js\";\r\nimport { $2dMooreNeighborhood } from \"../Constants/Util/CardinalNeighbors.js\";\r\nimport { DimensionsRegister } from \"./Dimensions/DimensionsRegister.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\r\nimport { RegionDataTool } from \"../../Tools/Data/WorldData/RegionDataTool.js\";\r\nimport { WorldSpaces } from \"./WorldSpaces.js\";\r\nconst chunkTool = new ChunkDataTool();\r\nconst columnTool = new ColumnDataTool();\r\nconst regionTool = new RegionDataTool();\r\nexport const WorldRegister = {\r\n    _dimensions: new Map(),\r\n    _cacheOn: false,\r\n    _chunkCache: new Map(),\r\n    _columnCache: new Map(),\r\n    cache: {\r\n        enable() {\r\n            WorldRegister._cacheOn = true;\r\n            WorldRegister._chunkCache.clear();\r\n            WorldRegister._columnCache.clear();\r\n        },\r\n        disable() {\r\n            WorldRegister._cacheOn = false;\r\n            WorldRegister._chunkCache.clear();\r\n            WorldRegister._columnCache.clear();\r\n        },\r\n        _addChunk(key, data) {\r\n            WorldRegister._chunkCache.set(key, data);\r\n        },\r\n        _addColumn(key, data) {\r\n            WorldRegister._columnCache.set(key, data);\r\n        },\r\n        _getChunk(key) {\r\n            return WorldRegister._chunkCache.get(key);\r\n        },\r\n        _getColumn(key) {\r\n            return WorldRegister._columnCache.get(key);\r\n        },\r\n    },\r\n    dimensions: {\r\n        add(id) {\r\n            const dimesnion = new Map();\r\n            id = DimensionsRegister.getDimensionStringId(id);\r\n            WorldRegister._dimensions.set(id, dimesnion);\r\n            return dimesnion;\r\n        },\r\n        get(id) {\r\n            id = DimensionsRegister.getDimensionStringId(id);\r\n            return WorldRegister._dimensions.get(id);\r\n        },\r\n    },\r\n    region: {\r\n        add(location, sab) {\r\n            let dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension) {\r\n                dimension = WorldRegister.dimensions.add(location[0]);\r\n            }\r\n            const region = this._getRegionData(sab);\r\n            const regionPOS = WorldSpaces.region.getPositionLocation(location);\r\n            regionTool.setRegion(region);\r\n            regionTool.setPositionData(regionPOS.x, regionPOS.y, regionPOS.z);\r\n            regionTool.setDimensionId(location[0]);\r\n            dimension.set(WorldSpaces.region.getKey(), region);\r\n            return region;\r\n        },\r\n        _getRegionData(sab) {\r\n            return {\r\n                columns: new Map(),\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        get(location) {\r\n            const dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const region = dimension.get(WorldSpaces.region.getKeyLocation(location));\r\n            if (!region)\r\n                return false;\r\n            return region;\r\n        },\r\n        remove(location) {\r\n            const dimension = WorldRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const key = WorldSpaces.region.getKeyLocation(location);\r\n            const region = dimension.get(key);\r\n            if (!region)\r\n                return false;\r\n            dimension.delete(key);\r\n            return true;\r\n        },\r\n    },\r\n    column: {\r\n        add(location, sab) {\r\n            let region = WorldRegister.region.get(location);\r\n            if (!region) {\r\n                let buffer = DataHooks.region.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                region = WorldRegister.region.add(location, buffer);\r\n                DataHooks.region.onNew.run(location);\r\n            }\r\n            const column = this._getColumnData(sab);\r\n            const columnPOS = WorldSpaces.column.getPositionLocation(location);\r\n            columnTool.setColumn(column);\r\n            columnTool.setPositionData(columnPOS.x, columnPOS.y, columnPOS.z);\r\n            columnTool.setDimensionId(location[0]);\r\n            region.columns.set(WorldSpaces.column.getIndex(), column);\r\n            return column;\r\n        },\r\n        _getColumnData(sab) {\r\n            return {\r\n                chunks: new Map(),\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        get(location) {\r\n            const columnKey = WorldSpaces.column.getKeyLocation(location);\r\n            let addColumn = false;\r\n            if (WorldRegister._cacheOn) {\r\n                const column = WorldRegister.cache._getColumn(columnKey);\r\n                if (column)\r\n                    return column;\r\n                addColumn = true;\r\n            }\r\n            const region = WorldRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const column = region.columns.get(WorldSpaces.column.getIndexLocation(location));\r\n            if (!column)\r\n                return false;\r\n            if (addColumn) {\r\n                WorldRegister.cache._addColumn(columnKey, column);\r\n            }\r\n            return column;\r\n        },\r\n        remove(location) {\r\n            const region = WorldRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const index = WorldSpaces.column.getIndexLocation(location);\r\n            const column = region.columns.get(index);\r\n            if (!column)\r\n                return false;\r\n            region.columns.delete(index);\r\n            return true;\r\n        },\r\n        fill(location) {\r\n            for (let cy = WorldBounds.bounds.MinY; cy < WorldBounds.bounds.MaxY; cy += WorldSpaces.chunk._bounds.y) {\r\n                location[2] = cy;\r\n                if (!WorldRegister.chunk.get(location)) {\r\n                    const chunk = DataHooks.chunk.onGetSync.run(location);\r\n                    if (!chunk)\r\n                        continue;\r\n                    WorldRegister.chunk.add(location, chunk);\r\n                }\r\n            }\r\n        },\r\n        height: {\r\n            getRelative(location) {\r\n                location = [...location];\r\n                const chunkWidth = WorldSpaces.chunk._bounds.x;\r\n                const chunkDepth = WorldSpaces.chunk._bounds.z;\r\n                let maxHeight = -Infinity;\r\n                const [dimension, x, y, z] = location;\r\n                for (const check of $2dMooreNeighborhood) {\r\n                    location[1] = check[0] * chunkWidth + x;\r\n                    location[3] = check[1] * chunkDepth + z;\r\n                    const height = this.getAbsolute(location);\r\n                    if (height > maxHeight) {\r\n                        maxHeight = height;\r\n                    }\r\n                }\r\n                return maxHeight;\r\n            },\r\n            getAbsolute(location) {\r\n                const column = WorldRegister.column.get(location);\r\n                if (!column)\r\n                    return WorldBounds.bounds.MinY;\r\n                if (column.chunks.size == 0)\r\n                    return WorldBounds.bounds.MinY;\r\n                let maxHeight = WorldBounds.bounds.MinY;\r\n                for (const [key, chunk] of column.chunks) {\r\n                    if (!chunk)\r\n                        continue;\r\n                    chunkTool.setChunk(chunk);\r\n                    const chunkPOS = chunkTool.getPositionData();\r\n                    let chunkMax = chunkTool.getTagValue(\"#dve_max_height\");\r\n                    if (chunkMax == 0)\r\n                        continue;\r\n                    chunkMax += chunkPOS.y;\r\n                    if (maxHeight < chunkMax) {\r\n                        maxHeight = chunkMax;\r\n                    }\r\n                }\r\n                return maxHeight + 1;\r\n            },\r\n        },\r\n    },\r\n    chunk: {\r\n        add(location, sab) {\r\n            let column = WorldRegister.column.get(location);\r\n            if (!column) {\r\n                let buffer = DataHooks.column.onGetSync.run(location);\r\n                if (!buffer)\r\n                    return;\r\n                column = WorldRegister.column.add(location, buffer);\r\n                DataHooks.column.onNew.run(location);\r\n            }\r\n            if (!column)\r\n                return;\r\n            const chunk = this._getChunkData(sab);\r\n            chunkTool.setChunk(chunk);\r\n            const chunkPOS = WorldSpaces.chunk.getPositionLocation(location);\r\n            chunkTool.setPositionData(chunkPOS.x, chunkPOS.y, chunkPOS.z);\r\n            chunkTool.setDimensionId(location[0]);\r\n            column.chunks.set(WorldSpaces.chunk.getIndex(), chunk);\r\n            DataHooks.chunk.onNew.run(location);\r\n            return chunk;\r\n        },\r\n        _getChunkData(sab) {\r\n            return {\r\n                buffer: sab,\r\n                data: new DataView(sab),\r\n            };\r\n        },\r\n        addFromServer(chunkBuffer) {\r\n            const sab = new SharedArrayBuffer(chunkBuffer.byteLength);\r\n            const temp = new Uint8Array(chunkBuffer);\r\n            const temp2 = new Uint8Array(sab);\r\n            temp2.set(temp, 0);\r\n            const chunk = this._getChunkData(sab);\r\n            chunkTool.setChunk(chunk);\r\n            const location = chunkTool.getLocationData();\r\n            let column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return;\r\n            column.chunks.set(WorldSpaces.chunk.getIndexLocation(location), chunk);\r\n            DataHooks.chunk.onNew.run(location);\r\n            return chunk;\r\n        },\r\n        get(location) {\r\n            const chunkKey = WorldSpaces.chunk.getKeyLocation(location);\r\n            let addChunk = false;\r\n            if (WorldRegister._cacheOn) {\r\n                const chunk = WorldRegister.cache._getChunk(chunkKey);\r\n                if (chunk)\r\n                    return chunk;\r\n                addChunk = true;\r\n            }\r\n            const column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const chunk = column.chunks.get(WorldSpaces.chunk.getIndex());\r\n            if (!chunk)\r\n                return;\r\n            if (addChunk) {\r\n                WorldRegister.cache._addChunk(chunkKey, chunk);\r\n            }\r\n            return chunk;\r\n        },\r\n        remove(location) {\r\n            const column = WorldRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const index = WorldSpaces.chunk.getIndexLocation(location);\r\n            const chunk = column.chunks.get(index);\r\n            if (!chunk)\r\n                return false;\r\n            column.chunks.delete(index);\r\n            return true;\r\n        },\r\n    },\r\n};\r\n","export class BoundingBox {\r\n    topPlane;\r\n    bottomPlane;\r\n    northPlane;\r\n    southPlane;\r\n    eastPlane;\r\n    westPlane;\r\n    bounds = {\r\n        minX: Infinity,\r\n        maxX: -Infinity,\r\n        minZ: Infinity,\r\n        maxZ: -Infinity,\r\n        minY: Infinity,\r\n        maxY: -Infinity,\r\n    };\r\n    constructor(data) {\r\n        this.topPlane = data.topPlane;\r\n        this._doMinMaxCheck(this.topPlane);\r\n        this.bottomPlane = data.bottomPlane;\r\n        this._doMinMaxCheck(this.bottomPlane);\r\n        this.northPlane = data.northPlane;\r\n        this._doMinMaxCheck(this.northPlane);\r\n        this.southPlane = data.southPlane;\r\n        this._doMinMaxCheck(this.southPlane);\r\n        this.eastPlane = data.eastPlane;\r\n        this._doMinMaxCheck(this.eastPlane);\r\n        this.westPlane = data.westPlane;\r\n        this._doMinMaxCheck(this.westPlane);\r\n    }\r\n    _doMinMaxCheck(plane) {\r\n        if (plane.minX <= this.bounds.minX)\r\n            this.bounds.minX = plane.minX;\r\n        if (plane.maxX >= this.bounds.maxX)\r\n            this.bounds.maxX = plane.maxX;\r\n        if (plane.minY <= this.bounds.minY)\r\n            this.bounds.minY = plane.minY;\r\n        if (plane.maxY >= this.bounds.maxY)\r\n            this.bounds.maxY = plane.maxY;\r\n        if (plane.minZ <= this.bounds.minZ)\r\n            this.bounds.minZ = plane.minZ;\r\n        if (plane.maxZ >= this.bounds.maxZ)\r\n            this.bounds.maxZ = plane.maxZ;\r\n    }\r\n}\r\n","export class Plane {\r\n    v1;\r\n    v2;\r\n    v3;\r\n    v4;\r\n    minX = Infinity;\r\n    maxX = -Infinity;\r\n    minZ = Infinity;\r\n    maxZ = -Infinity;\r\n    minY = Infinity;\r\n    maxY = -Infinity;\r\n    constructor(data) {\r\n        this.v1 = data.v1;\r\n        this.v2 = data.v2;\r\n        this.v3 = data.v3;\r\n        this.v4 = data.v4;\r\n        this._minMaxCompare(this.v1, this.v2);\r\n        this._minMaxCompare(this.v1, this.v3);\r\n        this._minMaxCompare(this.v1, this.v4);\r\n        this._minMaxCompare(this.v2, this.v3);\r\n        this._minMaxCompare(this.v2, this.v4);\r\n        this._minMaxCompare(this.v3, this.v4);\r\n    }\r\n    _compareVales(v1, v2, axis, minProperty, maxProperty) {\r\n        const c1 = v1;\r\n        const c2 = v2;\r\n        if (c1[axis] < this[minProperty]) {\r\n            if (c1[axis] <= c2[axis]) {\r\n                this[minProperty] = c1[axis];\r\n            }\r\n        }\r\n        if (c2[axis] < this[minProperty]) {\r\n            if (c2[axis] <= c1[axis]) {\r\n                this[minProperty] = c2[axis];\r\n            }\r\n        }\r\n        if (c1[axis] > this[maxProperty]) {\r\n            if (c1[axis] >= c2[axis]) {\r\n                this[maxProperty] = c1[axis];\r\n            }\r\n        }\r\n        if (c2[axis] > this[maxProperty]) {\r\n            if (c2[axis] >= c1[axis]) {\r\n                this[maxProperty] = c2[axis];\r\n            }\r\n        }\r\n    }\r\n    _minMaxCompare(v1, v2) {\r\n        this._compareVales(v1, v2, \"x\", \"minX\", \"maxX\");\r\n        this._compareVales(v1, v2, \"y\", \"minY\", \"maxY\");\r\n        this._compareVales(v1, v2, \"z\", \"minZ\", \"maxZ\");\r\n    }\r\n}\r\n","import { Vector3 } from \"./Vector3.js\";\r\nexport class SimpleBoundingBox {\r\n    origin;\r\n    dimensions;\r\n    bounds = {\r\n        minX: Infinity,\r\n        maxX: -Infinity,\r\n        minZ: Infinity,\r\n        maxZ: -Infinity,\r\n        minY: Infinity,\r\n        maxY: -Infinity,\r\n    };\r\n    checkBounds = {\r\n        minX: Infinity,\r\n        maxX: -Infinity,\r\n        minZ: Infinity,\r\n        maxZ: -Infinity,\r\n        minY: Infinity,\r\n        maxY: -Infinity,\r\n    };\r\n    checkOrigin = new Vector3(0, 0, 0);\r\n    _voxelCheckMap = {};\r\n    _voxelCheckPoints = [];\r\n    _voxelBottomCheckPoints = [];\r\n    _voxelOriginPoints = [];\r\n    constructor(origin, dimensions) {\r\n        this.origin = origin;\r\n        this.dimensions = dimensions;\r\n        const ov = origin;\r\n        this.checkOrigin.updateVector(ov.x, ov.y, ov.z);\r\n        this._updateBounds();\r\n        this._updateCheckBounds();\r\n    }\r\n    _updateBounds() {\r\n        const ov = this.origin;\r\n        this.bounds.minX = ov.x - this.dimensions.w / 2;\r\n        this.bounds.maxX = ov.x + this.dimensions.w / 2;\r\n        this.bounds.minZ = ov.z - this.dimensions.d / 2;\r\n        this.bounds.maxZ = ov.z + this.dimensions.d / 2;\r\n        this.bounds.minY = ov.y - this.dimensions.h / 2;\r\n        this.bounds.maxY = ov.y + this.dimensions.h / 2;\r\n    }\r\n    _updateCheckBounds() {\r\n        const cv = this.checkOrigin;\r\n        this.checkBounds.minX = cv.x - this.dimensions.w / 2;\r\n        this.checkBounds.maxX = cv.x + this.dimensions.w / 2;\r\n        this.checkBounds.minZ = cv.z - this.dimensions.d / 2;\r\n        this.checkBounds.maxZ = cv.z + this.dimensions.d / 2;\r\n        this.checkBounds.minY = cv.y - this.dimensions.h / 2;\r\n        this.checkBounds.maxY = cv.y + this.dimensions.h / 2;\r\n    }\r\n    updateOrigin(x, y, z) {\r\n        this.origin.updateVector(x, y, z);\r\n        this.origin.roundVector(2);\r\n        this._updateBounds();\r\n    }\r\n    setOriginToCheckOrigin() {\r\n        const cv = this.checkOrigin;\r\n        this.origin.updateVector(cv.x, cv.y, cv.z);\r\n        this.bounds.minX = this.checkBounds.minX;\r\n        this.bounds.maxX = this.checkBounds.maxX;\r\n        this.bounds.minZ = this.checkBounds.minZ;\r\n        this.bounds.maxZ = this.checkBounds.maxZ;\r\n        this.bounds.minY = this.checkBounds.minY;\r\n        this.bounds.maxY = this.checkBounds.maxY;\r\n    }\r\n    setCheckOrigin(x, y, z) {\r\n        this.checkOrigin.updateVector(x, y, z);\r\n        this._updateCheckBounds();\r\n    }\r\n    getCurrentOriginPoints() {\r\n        this._voxelOriginPoints = [];\r\n        const mx = this.bounds.minX;\r\n        const my = this.bounds.minY;\r\n        const mz = this.bounds.minZ;\r\n        for (let y = my; y <= this.bounds.maxY; y++) {\r\n            for (let x = mx - 1; x <= this.bounds.maxX + 1; x++) {\r\n                for (let z = mz - 1; z <= this.bounds.maxZ + 1; z++) {\r\n                    const key = this._getPositionKey(x, y, z);\r\n                    if (!this._voxelCheckMap[key]) {\r\n                        this._voxelOriginPoints.push([x, y, z]);\r\n                        this._voxelCheckMap[key] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._voxelCheckMap = {};\r\n        return this._voxelOriginPoints;\r\n    }\r\n    getVoxelCheckPoints() {\r\n        this._voxelCheckPoints = [];\r\n        const mx = this.checkBounds.minX;\r\n        const my = this.checkBounds.minY;\r\n        const mz = this.checkBounds.minZ;\r\n        for (let y = my; y <= this.checkBounds.maxY; y++) {\r\n            for (let x = mx; x <= this.checkBounds.maxX + 1; x++) {\r\n                for (let z = mz; z <= this.checkBounds.maxZ + 1; z++) {\r\n                    const key = this._getPositionKey(x, y, z);\r\n                    if (!this._voxelCheckMap[key]) {\r\n                        this._voxelCheckPoints.push([\r\n                            Math.floor(x),\r\n                            Math.floor(y),\r\n                            Math.floor(z),\r\n                        ]);\r\n                        this._voxelCheckMap[key] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._voxelCheckMap = {};\r\n        return this._voxelCheckPoints;\r\n    }\r\n    getVoxelBottomCheckPoints() {\r\n        this._voxelBottomCheckPoints = [];\r\n        const mx = this.checkBounds.minX;\r\n        const my = this.checkBounds.minY;\r\n        const mz = this.checkBounds.minZ;\r\n        for (let y = my - 1; y <= my; y++) {\r\n            for (let x = mx; x <= this.checkBounds.maxX + 1; x++) {\r\n                for (let z = mz; z <= this.checkBounds.maxZ + 1; z++) {\r\n                    const key = this._getPositionKey(x, y, z);\r\n                    if (!this._voxelCheckMap[key]) {\r\n                        this._voxelBottomCheckPoints.push([\r\n                            Math.floor(x),\r\n                            Math.floor(y),\r\n                            Math.floor(z),\r\n                        ]);\r\n                        this._voxelCheckMap[key] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._voxelCheckMap = {};\r\n        return this._voxelBottomCheckPoints;\r\n    }\r\n    _getPositionKey(x, y, z) {\r\n        return `${x}-${y}-${z}`;\r\n    }\r\n    isPointInsideBox(point) {\r\n        const box = this.bounds;\r\n        return (point.x >= box.minX &&\r\n            point.x <= box.maxX &&\r\n            point.y >= box.minY &&\r\n            point.y <= box.maxY &&\r\n            point.z >= box.minZ &&\r\n            point.z <= box.maxZ);\r\n    }\r\n    doesBoxIntersect(testBox) {\r\n        const box = this.bounds;\r\n        return (box.minX <= testBox.maxX &&\r\n            box.maxX >= testBox.minX &&\r\n            box.minY <= testBox.maxY &&\r\n            box.maxY >= testBox.minY &&\r\n            box.minZ <= testBox.maxZ &&\r\n            box.maxZ >= testBox.minZ);\r\n    }\r\n}\r\n","export class Vector3 {\r\n    x = 0;\r\n    y = 0;\r\n    z = 0;\r\n    _tv3 = {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n    };\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    updateFromArray(array, startIndex = 0) {\r\n        this.x = array[startIndex];\r\n        this.y = array[startIndex + 1];\r\n        this.z = array[startIndex + 2];\r\n    }\r\n    updateVector(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    updateFromVec3(vector) {\r\n        this.x = vector.x;\r\n        this.y = vector.y;\r\n        this.z = vector.z;\r\n    }\r\n    roundVector(deciamlPoints = 2) {\r\n        this.x = Number(this.x.toFixed(deciamlPoints));\r\n        this.y = Number(this.y.toFixed(deciamlPoints));\r\n        this.z = Number(this.z.toFixed(deciamlPoints));\r\n    }\r\n    translate(x, y, z) {\r\n        this.x = this.x + x;\r\n        this.y = this.y + y;\r\n        this.z = this.z + z;\r\n        return this;\r\n    }\r\n    getTranslated(x, y, z) {\r\n        this._tv3.x = this.x + x;\r\n        this._tv3.y = this.y + y;\r\n        this._tv3.z = this.z + z;\r\n        return this._tv3;\r\n    }\r\n    scaleXYZ(scaler) {\r\n        this.x = this.x * scaler;\r\n        this.y = this.y * scaler;\r\n        this.z = this.z * scaler;\r\n        return this;\r\n    }\r\n    scale(xScale, yScale, zScale) {\r\n        this.x = this.x * xScale;\r\n        this.y = this.y * yScale;\r\n        this.z = this.z * zScale;\r\n        return this;\r\n    }\r\n    getScaledXYZ(scaler) {\r\n        this._tv3.x = this.x * scaler;\r\n        this._tv3.y = this.y * scaler;\r\n        this._tv3.z = this.z * scaler;\r\n        return this._tv3;\r\n    }\r\n    getScaled(xScale, yScale, zScale) {\r\n        this._tv3.x = this.x * xScale;\r\n        this._tv3.y = this.y * yScale;\r\n        this._tv3.z = this.z * zScale;\r\n        return this._tv3;\r\n    }\r\n    addXYZ(add) {\r\n        this.x = this.x + add;\r\n        this.y = this.y + add;\r\n        this.z = this.z + add;\r\n        return this;\r\n    }\r\n    addFromVec3(vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        this.z += vector.z;\r\n        return this;\r\n    }\r\n    isZero() {\r\n        return !this.x && !this.y && !this.z;\r\n    }\r\n    subtractXYZ(subtract) {\r\n        this.x = this.x - subtract;\r\n        this.y = this.y - subtract;\r\n        this.z = this.z - subtract;\r\n        return this;\r\n    }\r\n    subtractFromObj(vector) {\r\n        this.x = this.x - vector.x;\r\n        this.y = this.y - vector.y;\r\n        this.z = this.z - vector.z;\r\n        return this;\r\n    }\r\n    getAddXYZ(add) {\r\n        this._tv3.x = this.x + add;\r\n        this._tv3.y = this.y + add;\r\n        this._tv3.z = this.z + add;\r\n        return this._tv3;\r\n    }\r\n    getSubtractXYZ(subtract) {\r\n        this._tv3.x = this.x - subtract;\r\n        this._tv3.y = this.y - subtract;\r\n        this._tv3.z = this.z - subtract;\r\n        return this._tv3;\r\n    }\r\n    addVector(vector3) {\r\n        this.x = vector3.x + this.x;\r\n        this.y = vector3.y + this.y;\r\n        this.z = vector3.z + this.z;\r\n        return this;\r\n    }\r\n    getAddedVector(vector3) {\r\n        this._tv3.x = vector3.x + this.x;\r\n        this._tv3.y = vector3.y + this.y;\r\n        this._tv3.z = vector3.z + this.z;\r\n        return this._tv3;\r\n    }\r\n    subtractVector(vector3) {\r\n        this.x = this.x - vector3.x;\r\n        this.y = this.y - vector3.y;\r\n        this.z = this.z - vector3.z;\r\n        return this;\r\n    }\r\n    getSubtractedVector(vector3) {\r\n        this._tv3.x = this.x - vector3.x;\r\n        this._tv3.y = this.y - vector3.y;\r\n        this._tv3.z = this.z - vector3.z;\r\n        return this._tv3;\r\n    }\r\n    scaleVector(vector3) {\r\n        this.x = this.x * vector3.x;\r\n        this.y = this.y * vector3.y;\r\n        this.z = this.z * vector3.z;\r\n        return this;\r\n    }\r\n    getScaledVector(vector3) {\r\n        this._tv3.x = this.x * vector3.x;\r\n        this._tv3.y = this.y * vector3.y;\r\n        this._tv3.z = this.z * vector3.z;\r\n        return this._tv3;\r\n    }\r\n    getLength() {\r\n        return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);\r\n    }\r\n    divide(scalar) {\r\n        this.x = this.x / scalar;\r\n        this.y = this.y / scalar;\r\n        this.z = this.z / scalar;\r\n        return this;\r\n    }\r\n    getDivided(scalar) {\r\n        this._tv3.x = this.x / scalar;\r\n        this._tv3.y = this.y / scalar;\r\n        this._tv3.z = this.z / scalar;\r\n        return this._tv3;\r\n    }\r\n    normalize() {\r\n        return this.divide(this.getLength());\r\n    }\r\n    isEqual(vector3) {\r\n        if (this.x != vector3.x) {\r\n            return false;\r\n        }\r\n        if (this.y != vector3.y) {\r\n            return false;\r\n        }\r\n        if (this.z != vector3.z) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    isNotEqual(vector3) {\r\n        if (this.x != vector3.x) {\r\n            return true;\r\n        }\r\n        if (this.y != vector3.y) {\r\n            return true;\r\n        }\r\n        if (this.z != vector3.z) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","export function Distance2D(x1, x2, y1, y2) {\r\n    var dx = x2 - x1;\r\n    var dy = y2 - y1;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","export function Distance3D(x1, y1, z1, x2, y2, z2) {\r\n    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2);\r\n}\r\n","import { Distance3D } from \"./Distance3d.js\";\r\nexport function Vec3ArrayDistanceSort(origion, array) {\r\n    //filter tasks to keep them close to the player\r\n    return array.sort((a, b) => {\r\n        const aDistance = Distance3D(a[0], a[1], a[2], origion[0], origion[1], origion[2]);\r\n        const bDistance = Distance3D(b[0], b[1], b[2], origion[0], origion[1], origion[2]);\r\n        //if a is closer then b put it first\r\n        if (aDistance < bDistance)\r\n            return -1;\r\n        //if b is closer then a put it first\r\n        if (aDistance > bDistance)\r\n            return 1;\r\n        //no change\r\n        return 0;\r\n    });\r\n}\r\nexport function LocationDataDistanceSort(origion, array) {\r\n    //filter tasks to keep them close to the player\r\n    return array.sort((a, b) => {\r\n        const aDistance = Distance3D(a[1], a[2], a[3], origion[1], origion[2], origion[3]);\r\n        const bDistance = Distance3D(b[1], b[2], b[3], origion[1], origion[2], origion[3]);\r\n        //if a is closer then b put it first\r\n        if (aDistance < bDistance)\r\n            return -1;\r\n        //if b is closer then a put it first\r\n        if (aDistance > bDistance)\r\n            return 1;\r\n        //no change\r\n        return 0;\r\n    });\r\n}\r\n","/** # Visit All\r\n * ---\r\n * Given a starting point and an end point it will visit all voxels that are between them.\r\n * @param startPoint\r\n * @param endPoint\r\n * @param visitor\r\n * @returns an array of numbers with a stride of 3 for positions\r\n */\r\nexport const VisitAll = (startPoint, endPoint, visitor = (x, y, z) => {\r\n    return true;\r\n}) => {\r\n    const gx0 = startPoint.x;\r\n    const gy0 = startPoint.y;\r\n    const gz0 = startPoint.z;\r\n    const gx1 = endPoint.x;\r\n    const gy1 = endPoint.y;\r\n    const gz1 = endPoint.z;\r\n    const positons = [];\r\n    const gx0idx = Math.floor(gx0);\r\n    const gy0idx = Math.floor(gy0);\r\n    const gz0idx = Math.floor(gz0);\r\n    const gx1idx = Math.floor(gx1);\r\n    const gy1idx = Math.floor(gy1);\r\n    const gz1idx = Math.floor(gz1);\r\n    const sx = gx1idx > gx0idx ? 1 : gx1idx < gx0idx ? -1 : 0;\r\n    const sy = gy1idx > gy0idx ? 1 : gy1idx < gy0idx ? -1 : 0;\r\n    const sz = gz1idx > gz0idx ? 1 : gz1idx < gz0idx ? -1 : 0;\r\n    let gx = gx0idx;\r\n    let gy = gy0idx;\r\n    let gz = gz0idx;\r\n    const gxp = gx0idx + (gx1idx > gx0idx ? 1 : 0);\r\n    const gyp = gy0idx + (gy1idx > gy0idx ? 1 : 0);\r\n    const gzp = gz0idx + (gz1idx > gz0idx ? 1 : 0);\r\n    const vx = gx1 === gx0 ? 1 : gx1 - gx0;\r\n    const vy = gy1 === gy0 ? 1 : gy1 - gy0;\r\n    const vz = gz1 === gz0 ? 1 : gz1 - gz0;\r\n    const vxvy = vx * vy;\r\n    const vxvz = vx * vz;\r\n    const vyvz = vy * vz;\r\n    let errx = (gxp - gx0) * vyvz;\r\n    let erry = (gyp - gy0) * vxvz;\r\n    let errz = (gzp - gz0) * vxvy;\r\n    const derrx = sx * vyvz;\r\n    const derry = sy * vxvz;\r\n    const derrz = sz * vxvy;\r\n    do {\r\n        if (!visitor(gx, gy, gz))\r\n            break;\r\n        positons.push(gx, gy, gz);\r\n        if (gx === gx1idx && gy === gy1idx && gz === gz1idx)\r\n            break;\r\n        let xr = Math.abs(errx);\r\n        let yr = Math.abs(erry);\r\n        let zr = Math.abs(errz);\r\n        if (sx !== 0 && (sy === 0 || xr < yr) && (sz === 0 || xr < zr)) {\r\n            gx += sx;\r\n            errx += derrx;\r\n        }\r\n        else if (sy !== 0 && (sz === 0 || yr < zr)) {\r\n            gy += sy;\r\n            erry += derry;\r\n        }\r\n        else if (sz !== 0) {\r\n            gz += sz;\r\n            errz += derrz;\r\n        }\r\n    } while (true);\r\n    return positons;\r\n};\r\n","export {};\r\n","import { BoundingBox } from \"./Classes/BoundingBox.js\";\r\nimport { Plane } from \"./Classes/Plane.js\";\r\nimport { SimpleBoundingBox } from \"./Classes/SimpleBoundingBox.js\";\r\nimport { Vector3 } from \"./Classes/Vector3.js\";\r\nimport { VisitAll } from \"./Functions/VisitAll.js\";\r\n/**# Voxel Math\r\n * ---\r\n * Can be used in any thread that needs it.\r\n * Has functions for collision detection, finding voxels in a direction, and path finding.\r\n */\r\nexport const VoxelMath = {\r\n    visitAll: VisitAll,\r\n    getVector3(x, y, z) {\r\n        return new Vector3(x, y, z);\r\n    },\r\n    getPlane(pv1, pv2, pv3, pv4) {\r\n        return new Plane({\r\n            v1: pv1,\r\n            v2: pv2,\r\n            v3: pv3,\r\n            v4: pv4,\r\n        });\r\n    },\r\n    getSimpleBoundingBox(origin, dimensions) {\r\n        return new SimpleBoundingBox(origin, dimensions);\r\n    },\r\n    getBoundingBox(data) {\r\n        return new BoundingBox(data);\r\n    },\r\n    convertToOriginGridSpace(position) {\r\n        position[0] = Math.round(position[0]) + 0.5;\r\n        position[1] = Math.round(position[1]) + 0.5;\r\n        position[2] = Math.round(position[2]) + 0.5;\r\n        return position;\r\n    },\r\n    distance2D(x1, x2, y1, y2) {\r\n        var dx = x2 - x1;\r\n        var dy = y2 - y1;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n    distance3D(x1, y1, z1, x2, y2, z2) {\r\n        const a = x2 - x1;\r\n        const b = y2 - y1;\r\n        const c = z2 - z1;\r\n        return Math.sqrt(a * a + b * b + c * c);\r\n    },\r\n};\r\n","export * from \"./VoxelMath.js\";\r\nexport * from \"./Classes/BoundingBox.js\";\r\nexport * from \"./Classes/Plane.js\";\r\nexport * from \"./Classes/SimpleBoundingBox.js\";\r\nexport * from \"./Classes/Vector3.js\";\r\nexport * from \"./Classes/Vector3.js\";\r\nexport * from \"./Functions/Distance2d.js\";\r\nexport * from \"./Functions/Distance3d.js\";\r\nexport * from \"./Functions/DistnaceSort.js\";\r\nexport * from \"./Functions/VisitAll.js\";\r\nexport * from \"./Types/Math.types.js\";\r\n","import { Util } from \"../../Global/Util.helper.js\";\r\nimport { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\r\nimport { LocationBoundTool } from \"./LocationBoundTool.js\";\r\nimport { WorldDataTagIDs } from \"../../Data/Constants/Tags/WorldDataTagIds.js\";\r\nexport class DataToolBase extends LocationBoundTool {\r\n    tags;\r\n    _c;\r\n    constructor() {\r\n        super();\r\n    }\r\n    getTagValue(id) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.getTag(id);\r\n    }\r\n    setTagValue(id, value) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.setTag(id, value);\r\n    }\r\n    getArrayTagValue(id, index) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.getArrayTagValue(id, index);\r\n    }\r\n    setArrayTagValue(id, index, value) {\r\n        this.tags.setBuffer(this._c);\r\n        return this.tags.setArrayTagValue(id, index, value);\r\n    }\r\n    setBuffer(buffer) {\r\n        this._c = buffer;\r\n        this.tags.setBuffer(this._c);\r\n    }\r\n    getBuffer() {\r\n        if (this._c instanceof DataView)\r\n            return this._c.buffer;\r\n        return this._c;\r\n    }\r\n    getAsArrayBuffer() {\r\n        return Util.converSABToBuffer(this.getBuffer());\r\n    }\r\n    getBufferSize() {\r\n        return this.tags.tagSize;\r\n    }\r\n    loadInAt(x, y, z) {\r\n        this.setXYZ(x, y, z);\r\n        return this.loadIn();\r\n    }\r\n    loadInAtLocation(location) {\r\n        this.setLocation(location);\r\n        return this.loadIn();\r\n    }\r\n}\r\nexport class EncodedPositionDataTool extends DataToolBase {\r\n    position = { x: 0, y: 0, z: 0 };\r\n    constructor() {\r\n        super();\r\n    }\r\n    getPositionData() {\r\n        this.position.x = this.getTagValue(WorldDataTagIDs.positionX);\r\n        this.position.y = this.getTagValue(WorldDataTagIDs.positionY);\r\n        this.position.z = this.getTagValue(WorldDataTagIDs.positionZ);\r\n        return this.position;\r\n    }\r\n    setPositionData(x, y, z) {\r\n        this.setTagValue(WorldDataTagIDs.positionX, x);\r\n        this.setTagValue(WorldDataTagIDs.positionY, y);\r\n        this.setTagValue(WorldDataTagIDs.positionZ, z);\r\n        return this.position;\r\n    }\r\n    setDimensionId(dimensionId) {\r\n        this.setTagValue(WorldDataTagIDs.dimensionId, DimensionsRegister.getDimensionNumericId(dimensionId));\r\n    }\r\n    getDimensionId() {\r\n        return DimensionsRegister.getDimensionStringId(this.getTagValue(WorldDataTagIDs.dimensionId));\r\n    }\r\n    getLocationData() {\r\n        const pos = this.getPositionData();\r\n        return [this.getDimensionId(), pos.x, pos.y, pos.z];\r\n    }\r\n}\r\n","export class LocationBoundTool {\r\n    location = [\"main\", 0, 0, 0];\r\n    get dimension() {\r\n        return this.location[0];\r\n    }\r\n    set dimension(dimension) {\r\n        this.location[0] = dimension;\r\n    }\r\n    get x() {\r\n        return this.location[1];\r\n    }\r\n    set x(value) {\r\n        this.location[1] = value;\r\n    }\r\n    get y() {\r\n        return this.location[2];\r\n    }\r\n    set y(value) {\r\n        this.location[2] = value;\r\n    }\r\n    get z() {\r\n        return this.location[3];\r\n    }\r\n    set z(value) {\r\n        this.location[3] = value;\r\n    }\r\n    setDimension(dimensionId) {\r\n        this.location[0] = dimensionId;\r\n        return this;\r\n    }\r\n    getLocation() {\r\n        return this.location;\r\n    }\r\n    setXYZ(x, y, z) {\r\n        this.location[1] = x;\r\n        this.location[2] = y;\r\n        this.location[3] = z;\r\n        return this;\r\n    }\r\n    setXZ(x, z) {\r\n        this.setXYZ(x, this.location[2], z);\r\n        return this;\r\n    }\r\n    setLocation(location) {\r\n        this.location[0] = location[0];\r\n        this.location[1] = location[1];\r\n        this.location[2] = location[2];\r\n        this.location[3] = location[3];\r\n        return this;\r\n    }\r\n}\r\n","import { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\r\nimport { VoxelReader } from \"../../Data/Voxel/VoxelReader.js\";\r\nimport { VoxelTags } from \"../../Data/Voxel/VoxelTags.js\";\r\nimport { VoxelPaletteReader } from \"../../Data/Voxel/VoxelPalette.js\";\r\nimport { ChunkDataTool } from \"./WorldData/ChunkDataTool.js\";\r\nimport { HeightMapTool } from \"./WorldData/HeightMapTool.js\";\r\nimport { DataToolBase } from \"../Classes/DataToolBase.js\";\r\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\r\nimport { ColumnDataTool } from \"./WorldData/ColumnDataTool.js\";\r\nimport { LightData } from \"../../Data/Light/LightByte.js\";\r\nimport { VoxelTagIDs } from \"../../Data/Constants/Tags/VoxelTagIds.js\";\r\nimport { Register } from \"../../Data/Register/Register.js\";\r\nexport class DataTool extends DataToolBase {\r\n    static _dtutil = new DataTool();\r\n    _chunkTool = new ChunkDataTool();\r\n    static _heightMapTool = new HeightMapTool();\r\n    static _columntool = new ColumnDataTool();\r\n    _locationKey = \"\";\r\n    _loadedIn = false;\r\n    _mode = \"World\";\r\n    data = {\r\n        raw: [0, 0, 0, 0],\r\n        id: 0,\r\n        baseId: 0,\r\n        secondaryId: 0,\r\n        secondaryBaseId: 0,\r\n    };\r\n    __secondary = false;\r\n    tags = VoxelTags;\r\n    setDimension(dimensionId) {\r\n        this.location[0] = DimensionsRegister.getDimensionStringId(dimensionId);\r\n        return this;\r\n    }\r\n    setSecondary(enable) {\r\n        this.__secondary = enable;\r\n        if (enable) {\r\n            VoxelTags.setVoxel(this.data.secondaryBaseId);\r\n        }\r\n        else {\r\n            VoxelTags.setVoxel(this.data.baseId);\r\n        }\r\n        return this;\r\n    }\r\n    _getBaseId(id) {\r\n        return VoxelPaletteReader.id.baseNumeric(id);\r\n    }\r\n    loadInRaw(rawData) {\r\n        this.data.raw = rawData;\r\n        this.__process();\r\n    }\r\n    __process() {\r\n        this.data.id = this.data.raw[0];\r\n        this.data.secondaryId = this.data.raw[3];\r\n        this.data.baseId = this._getBaseId(this.data.id);\r\n        if (this.data.secondaryId > 1) {\r\n            this.data.secondaryBaseId = this._getBaseId(this.data.secondaryId);\r\n        }\r\n        else {\r\n            this.data.secondaryBaseId = 0;\r\n        }\r\n        VoxelTags.setVoxel(this.data.baseId);\r\n    }\r\n    loadIn() {\r\n        this._c = this.tags.data;\r\n        if (this._mode == \"World\") {\r\n            if (!this._chunkTool.setLocation(this.location).loadIn())\r\n                return false;\r\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\r\n            this.data.raw[0] = this._chunkTool.segments.id.get(index);\r\n            this.data.raw[1] = this._chunkTool.segments.light.get(index);\r\n            this.data.raw[2] = this._chunkTool.segments.state.get(index);\r\n            this.data.raw[3] = this._chunkTool.segments.secondaryId.get(index);\r\n            this.__process();\r\n            this._loadedIn = true;\r\n            return true;\r\n        }\r\n        if (this._mode == \"Entity\") {\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n    commit(heightMapUpdate = 0) {\r\n        if (!this._loadedIn)\r\n            return false;\r\n        if (this._mode == \"World\") {\r\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\r\n            this._chunkTool.segments.id.set(index, this.data.raw[0]);\r\n            this._chunkTool.segments.light.set(index, this.data.raw[1]);\r\n            this._chunkTool.segments.state.set(index, this.data.raw[2]);\r\n            this._chunkTool.segments.secondaryId.set(index, this.data.raw[3]);\r\n            if (heightMapUpdate) {\r\n                DataTool._heightMapTool.chunk._c = this._chunkTool._c;\r\n                const substance = this.getTemplateSubstance();\r\n                //on add\r\n                if (heightMapUpdate == 1) {\r\n                    DataTool._heightMapTool.chunk.update(\"add\", substance, this.location);\r\n                }\r\n                //on remove\r\n                if (heightMapUpdate == 2) {\r\n                    DataTool._heightMapTool.chunk.update(\"remove\", substance, this.location);\r\n                }\r\n            }\r\n            if (DataTool._columntool.setLocation(this.location).loadIn()) {\r\n                DataTool._columntool.markAsNotStored();\r\n            }\r\n            this._loadedIn = false;\r\n            return true;\r\n        }\r\n        if (this._mode == \"Entity\") {\r\n        }\r\n        return false;\r\n    }\r\n    hasRGBLight() {\r\n        const light = this.getLight();\r\n        if (light <= 0)\r\n            false;\r\n        return LightData.hasRGBLight(light);\r\n    }\r\n    hasSunLight() {\r\n        const light = this.getLight();\r\n        if (light <= 0)\r\n            false;\r\n        return LightData.hasSunLight(light);\r\n    }\r\n    getLight() {\r\n        const vID = this.getId(true);\r\n        VoxelTags.setVoxel(vID);\r\n        if (vID == 0)\r\n            return this.data.raw[1];\r\n        if (vID < 2)\r\n            return -1;\r\n        const lightValue = this.getTagValue(VoxelTagIDs.lightValue);\r\n        if (this.isOpaque()) {\r\n            if (this.getTagValue(VoxelTagIDs.isLightSource) && lightValue) {\r\n                return lightValue;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        if (this.getTagValue(\"#dve_is_light_source\") && lightValue) {\r\n            return LightData.mixLight(this.data.raw[1], lightValue);\r\n        }\r\n        return this.data.raw[1];\r\n    }\r\n    setLight(light) {\r\n        this.data.raw[1] = light;\r\n        return this;\r\n    }\r\n    isOpaque() {\r\n        const substance = this.getSubstance();\r\n        if (substance == \"#dve_solid\")\r\n            return true;\r\n    }\r\n    getLevel() {\r\n        return VoxelReader.getLevel(this.data.raw[2]);\r\n    }\r\n    setLevel(level) {\r\n        this.data.raw[2] = VoxelReader.setLevel(this.data.raw[2], level);\r\n        return this;\r\n    }\r\n    getLevelState() {\r\n        return VoxelReader.getLevelState(this.data.raw[2]);\r\n    }\r\n    setLevelState(state) {\r\n        this.data.raw[2] = VoxelReader.setLevelState(this.data.raw[2], state);\r\n        return this;\r\n    }\r\n    getShapeState() {\r\n        return VoxelReader.getShapeState(this.data.raw[2]);\r\n    }\r\n    setShapeState(state) {\r\n        this.data.raw[2] = VoxelReader.setShapeState(this.data.raw[2], state);\r\n        return this;\r\n    }\r\n    hasSecondaryVoxel() {\r\n        return this.data.secondaryBaseId > 1;\r\n    }\r\n    //voxel data\r\n    getShapeId() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.shapeID, VoxelTags.getTag(VoxelTagIDs.shapeID));\r\n    }\r\n    isLightSource() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return false;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource) == 1;\r\n    }\r\n    getLightSourceValue() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.lightValue);\r\n    }\r\n    getSubstance() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"#dve_transparent\";\r\n        VoxelTags.setVoxel(vID);\r\n        const s = (Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.substance, VoxelTags.getTag(VoxelTagIDs.substance)));\r\n        return s;\r\n    }\r\n    getMaterial() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"none\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.material, VoxelTags.getTag(VoxelTagIDs.material));\r\n    }\r\n    getHardness() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.hardness);\r\n    }\r\n    getCollider() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return \"none\";\r\n        VoxelTags.setVoxel(vID);\r\n        return Register.stringMaps.getStringMapValue(\"voxel\", VoxelTagIDs.colliderID, VoxelTags.getTag(VoxelTagIDs.colliderID));\r\n    }\r\n    checkCollisions() {\r\n        const vID = this.getId(true);\r\n        if (vID == 0)\r\n            return false;\r\n        if (vID == 1)\r\n            return true;\r\n        VoxelTags.setVoxel(vID);\r\n        return this.getTagValue(VoxelTagIDs.checkCollisions) == 1;\r\n    }\r\n    getTemplateSubstance() {\r\n        let substance = this.getSubstance();\r\n        if (substance == \"#dve_transparent\") {\r\n            substance = \"#dve_solid\";\r\n        }\r\n        return substance;\r\n    }\r\n    getState() {\r\n        if (this.__secondary) {\r\n            return this.data.secondaryId - this.data.secondaryBaseId;\r\n        }\r\n        return this.data.id - this.data.baseId;\r\n    }\r\n    isRich() {\r\n        const vID = this.getId(true);\r\n        if (vID < 2)\r\n            return 0;\r\n        VoxelTags.setVoxel(vID);\r\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource);\r\n    }\r\n    //util\r\n    setAir() {\r\n        this.data.raw[0] = 0;\r\n        this.__process();\r\n        return this;\r\n    }\r\n    isAir() {\r\n        return 0 == this.data.raw[0];\r\n    }\r\n    setBarrier() {\r\n        this.data.raw[0] = 1;\r\n        this.__process();\r\n        return this;\r\n    }\r\n    isBarrier() {\r\n        return 1 == this.data.raw[0];\r\n    }\r\n    //voxel id\r\n    getId(base = false) {\r\n        if (this.__secondary) {\r\n            if (!base)\r\n                return this.data.secondaryId;\r\n            return this.data.secondaryBaseId;\r\n        }\r\n        if (!base)\r\n            return this.data.id;\r\n        return this.data.baseId;\r\n    }\r\n    setId(id) {\r\n        if (this.__secondary) {\r\n            this.data.raw[3] = id;\r\n            this.data.secondaryId = id;\r\n            this.data.secondaryBaseId = this._getBaseId(id);\r\n            return this;\r\n        }\r\n        this.data.raw[0] = id;\r\n        this.data.id = id;\r\n        this.data.baseId = this._getBaseId(id);\r\n        return this;\r\n    }\r\n    getStringId() {\r\n        if (this.__secondary) {\r\n            return VoxelPaletteReader.id.stringFromNumber(this.data.secondaryBaseId);\r\n        }\r\n        return VoxelPaletteReader.id.stringFromNumber(this.data.baseId);\r\n    }\r\n    //util\r\n    isRenderable() {\r\n        if (this.data.id < 2 && this.data.secondaryId < 2)\r\n            return false;\r\n        return true;\r\n    }\r\n    isSameVoxel(cx, cy, cz) {\r\n        DataTool._dtutil.loadInAt(cx, cy, cz);\r\n        if (this.__secondary) {\r\n            return this.data.secondaryBaseId == DataTool._dtutil.data.secondaryBaseId;\r\n        }\r\n        return this.data.baseId == DataTool._dtutil.data.baseId;\r\n    }\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { ChunkTagIDs } from \"../../../Data/Constants/Tags/ChunkTagIds.js\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nexport class ChunkDataTool extends EncodedPositionDataTool {\r\n    tags = ChunkTags;\r\n    constructor() {\r\n        super();\r\n        this.segments.id._s = this;\r\n        this.segments.light._s = this;\r\n        this.segments.state._s = this;\r\n        this.segments.secondaryId._s = this;\r\n    }\r\n    loadIn() {\r\n        WorldSpaces.chunk.updateLoaction(this.location);\r\n        const chunk = WorldRegister.chunk.get(this.location);\r\n        if (!chunk)\r\n            return false;\r\n        this.tags.setBuffer(chunk.data);\r\n        this._c = chunk.data;\r\n        return true;\r\n    }\r\n    setChunk(chunk) {\r\n        this.tags.setBuffer(chunk.data);\r\n        this._c = chunk.data;\r\n        return this;\r\n    }\r\n    segments = {\r\n        id: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelIDSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelIDSegment, index, value);\r\n            },\r\n        },\r\n        light: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelLightSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelLightSegment, index, value);\r\n            },\r\n        },\r\n        state: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelStateSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelStateSegment, index, value);\r\n            },\r\n        },\r\n        secondaryId: {\r\n            _s: {},\r\n            get(index) {\r\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index);\r\n            },\r\n            set(index, value) {\r\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index, value);\r\n            },\r\n        },\r\n    };\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { ColumnTags } from \"../../../Data/World/Column/ColumnTags.js\";\r\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\r\nexport class ColumnDataTool extends EncodedPositionDataTool {\r\n    tags = ColumnTags;\r\n    _column = {};\r\n    loadIn() {\r\n        const column = WorldRegister.column.get(this.location);\r\n        if (!column)\r\n            return false;\r\n        this.tags.setBuffer(column.data);\r\n        this._c = column.data;\r\n        this._column = column;\r\n        return true;\r\n    }\r\n    setColumn(column) {\r\n        this.tags.setBuffer(column.data);\r\n        this._c = column.data;\r\n        this._column = column;\r\n        return this;\r\n    }\r\n    getColumn() {\r\n        return this._column;\r\n    }\r\n    getNumChunks() {\r\n        return this._column.chunks.size;\r\n    }\r\n    getBufferSizeForWholeColumn() {\r\n        return ColumnTags.tagSize + ChunkTags.tagSize * this.getNumChunks();\r\n    }\r\n    isStored() {\r\n        return this.getTagValue(\"#dve_is_stored\") == 1;\r\n    }\r\n    markAsNotStored() {\r\n        this.setTagValue(\"#dve_is_stored\", 0);\r\n        return this;\r\n    }\r\n    markAsStored() {\r\n        this.setTagValue(\"#dve_is_stored\", 1);\r\n        return this;\r\n    }\r\n    isPersistent() {\r\n        return this.getTagValue(\"#dve_persistent\") == 1;\r\n    }\r\n    setPersistence(value) {\r\n        this.setTagValue(\"#dve_persistent\", value ? 1 : 0);\r\n    }\r\n    isDirty() {\r\n        return this.getTagValue(\"#dve_is_dirty\") == 1;\r\n    }\r\n    setDirty(value) {\r\n        this.setTagValue(\"#dve_is_dirty\", value ? 1 : 0);\r\n    }\r\n    getLastSaveTimestamp() {\r\n        return this.getTagValue(\"#dve_last_save_timestamp\");\r\n    }\r\n    setLastSaveTimestamp() {\r\n        return this.setTagValue(\"#dve_last_save_timestamp\", Date.now());\r\n    }\r\n    getLastAnalyzerUpdateTimestamp() {\r\n        return this.getTagValue(\"#dve_last_analyzer_update_timestamp\");\r\n    }\r\n    setLastAnalyzerUpdateTimestamp() {\r\n        return this.setTagValue(\"#dve_last_analyzer_update_timestamp\", Date.now());\r\n    }\r\n}\r\n","//Data\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { ChunkDataTool } from \"./ChunkDataTool.js\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nexport class HeightMapTool {\r\n    static _chunkTool = new ChunkDataTool();\r\n    _data = {\r\n        dimension: \"main\",\r\n    };\r\n    constructor() {\r\n        this.chunk._s = this;\r\n        //  this.column._s = this;\r\n    }\r\n    setDimension(dimensionId) {\r\n        this._data.dimension = dimensionId;\r\n    }\r\n    chunk = {\r\n        _p: {\r\n            x: 0,\r\n            z: 0,\r\n        },\r\n        _c: new DataView(new ArrayBuffer(0)),\r\n        _s: {},\r\n        loadInAt(x, y, z) {\r\n            const chunk = WorldRegister.chunk.get([this._s._data.dimension, x, y, z]);\r\n            if (!chunk)\r\n                return false;\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        loadInAtLocation(location) {\r\n            const chunk = WorldRegister.chunk.get(location);\r\n            if (!chunk)\r\n                return false;\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        setChunk(chunk) {\r\n            HeightMapTool._chunkTool.setChunk(chunk);\r\n            this._c = chunk.data;\r\n        },\r\n        setXZ(x, z) {\r\n            this._p.x = x;\r\n            this._p.z = z;\r\n            return this;\r\n        },\r\n        getMinMax() {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            return [\r\n                HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\"),\r\n                HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\"),\r\n            ];\r\n        },\r\n        getMin(substance = \"all\") {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            if (substance == \"all\") {\r\n                return HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\");\r\n            }\r\n            return 0;\r\n        },\r\n        getMax(substance = \"all\") {\r\n            HeightMapTool._chunkTool._c = this._c;\r\n            if (substance == \"all\") {\r\n                return HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\");\r\n            }\r\n            return 0;\r\n        },\r\n        update(mode, substance = \"all\", location) {\r\n            if (mode == \"add\") {\r\n                HeightMapTool._chunkTool._c = this._c;\r\n                const minY = HeightMapTool._chunkTool.getTagValue(\"#dve_min_height\");\r\n                const maxY = HeightMapTool._chunkTool.getTagValue(\"#dve_max_height\");\r\n                const voxelPOS = WorldSpaces.voxel.getPositionLocation(location);\r\n                if (minY > voxelPOS.y) {\r\n                    HeightMapTool._chunkTool.setTagValue(\"#dve_min_height\", voxelPOS.y);\r\n                }\r\n                if (maxY < voxelPOS.y) {\r\n                    HeightMapTool._chunkTool.setTagValue(\"#dve_max_height\", voxelPOS.y);\r\n                }\r\n            }\r\n        },\r\n    };\r\n}\r\n","//objects\r\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\r\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\r\nimport { RegionTags } from \"../../../Data/World/Region/RegionTags.js\";\r\nexport class RegionDataTool extends EncodedPositionDataTool {\r\n    tags = RegionTags;\r\n    _region = {};\r\n    loadIn() {\r\n        const reigon = WorldRegister.region.get(this.location);\r\n        if (!reigon)\r\n            return false;\r\n        this.tags.setBuffer(reigon.data);\r\n        this._region = reigon;\r\n        this._c = reigon.data;\r\n        return true;\r\n    }\r\n    setRegion(region) {\r\n        this.tags.setBuffer(region.data);\r\n        this._region = region;\r\n        this._c = region.data;\r\n        return this;\r\n    }\r\n    getRegion() {\r\n        return this._region;\r\n    }\r\n    getRegionDataCount() {\r\n        const region = this._region;\r\n        let totalChunks = 0;\r\n        region.columns.forEach((column) => {\r\n            totalChunks += column.chunks.size;\r\n        });\r\n        return {\r\n            chunks: totalChunks,\r\n            columns: region.columns.size,\r\n        };\r\n    }\r\n}\r\n"],"names":[],"sourceRoot":""}